{"version":3,"sources":["AlgoVisualizer/Node/Node.jsx","AlgoVisualizer/Stats/Stats.jsx","AlgoVisualizer/Legend/Legend.jsx","Algorithms/helpers.js","Algorithms/Search/dijkstra.js","Algorithms/Search/aStar.js","Algorithms/Search/dfs.js","Algorithms/Search/bfs.js","Algorithms/Generator/recursiveDivision.js","AlgoVisualizer/AlgoVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","row","col","type","text","weight","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","typeClass","id","className","Component","Stats","lastAlgoRunString","runTimeSeconds","numNodesInPath","numVisitedNodes","numWalls","numWeights","weightValue","Legend","animateAlgorithm","algoVisualizer","visitedNodesInOrderList","nodesInShortestPathOrderList","length","i","Set","size","setTimeout","nodesInShortestPathOrder","delay","node","nodeElement","document","getElementById","replace","setState","running","animateShortestPath","oldClasses","getAllNodes","grid","nodes","push","getUnvisitedNeighbors","neighbors","filter","neighbor","isVisited","getNodesInShortestPathOrder","finishNode","currentNode","unshift","previousNode","clearPath","callback","checkpointNodes","checkpointNodeInfo","distance","Infinity","createNode","isPathDrawn","heuristic","randomInteger","min","max","Math","floor","random","resetGrid","startNodeCoords","finishNodeCoords","getInitialGrid","currentRow","startRow","startCol","finishRow","finishCol","getEuclideanDistance","x1","y1","x2","y2","a","b","sqrt","visualizAlgorithm","computeAlgorithm","startTime","destinationNodeInfo","gridCopy","startNode","originalStartNodeCoords","visitedNodesInOrder","isPathPossible","shortestPath","sort","nodeA","nodeB","getDestinationNodeInfo","coords","Date","getTime","_","cloneDeep","flat","visitedNodesToAnimate","pathNodesToAnimate","computeDijkstra","visitedNodes","unvisitedNodes","closestNode","shift","updateUnvisitedNeighbors","unvisitedNeighbors","computeAStar","abs","getGridWithHeuristics","updateneighbors","getNeighbors","computeDFS","unvisitedNeighbor","newVisitedNodes","computeBFS","queue","path","includes","visualizeRecursiveDivision","generatedWallsInOrder","computeRecursiveDivision","chamber","wallLineRow","wallLineCol","entranceIdx","slice","newTopChamber","newBottomChamber","currentRowTopChamber","currentRowBottomChamber","newLeftChamber","newRightChamber","currentRowLeftChamber","currentRowRightChamber","animateGeneration","setWalls","walls","newNode","AlgoVisualizer","draggingCheckpointNodeInfo","dragging","drawMode","newGrid","nodeType","getNodeUpdatedGrid","getWallUpdatedGrid","forEach","enteredNodeType","enteredNodeID","randomEmptyNodeCoords","emptyNodes","newRow","nodeRow","getRandomEmptyNodeCoords","getEmptyNodes","startNodeRow","finishNodeRow","checkpointNodeRow","checkpointNode","checkpointNodeCoords","reverse","disabled","onClick","addCheckpointNode","toggleNodeDrawType","randomizeStartFinishNodes","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.b60720d0.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            type,\r\n            text,\r\n            weight,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave\r\n        } = this.props;\r\n\r\n        const typeClass = type === \"finishNode\"\r\n            ? 'node-finish'\r\n            : type === \"startNode\"\r\n            ? 'node-start'\r\n            : type === \"checkpointNode\"\r\n            ? 'node-checkpoint'\r\n            : type === \"wallNode\"\r\n            ? 'node-wall'\r\n            : type === \"weightNode\"\r\n            ? 'node-weight'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className = {`node ${typeClass}`}\r\n                weight = {weight}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseLeave={() => onMouseLeave(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}><div className='node-center'>{text}</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\n\r\nimport './Stats.css';\r\n\r\nexport default class Stats extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            lastAlgoRunString,\r\n            runTimeSeconds,\r\n            numNodesInPath,\r\n            numVisitedNodes,\r\n            numWalls,\r\n            numWeights,\r\n            weightValue\r\n        } = this.props;\r\n\r\n        return (\r\n            <div id='stats-component' className=\"stats-component\">\r\n                        <p className=\"stat\"><b>Last Algorithm Run: </b> {lastAlgoRunString}</p>\r\n                        <p className=\"stat\"><b>Calculation Time: </b> {runTimeSeconds}ms</p>\r\n                        <p className=\"stat\"><b>Nodes in Path:</b> {numNodesInPath}</p>\r\n                        <p className=\"stat\"><b>Nodes Visited:</b> {numVisitedNodes}</p>\r\n                        <p className=\"stat\"><b>Walls:</b> {numWalls}</p>\r\n                        <p className=\"stat\"><b>Weights:</b> {numWeights}</p>\r\n                        <p className=\"stat\"><b>Weight Value:</b> {weightValue}</p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\nimport './Legend.css';\r\nimport '../Node/Node.css';\r\n\r\nexport default class Legend extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id='legend-component' className=\"legend-component\">\r\n                        <div className='node node-start'></div><p className=\"legend-item\"><b> Start</b></p>\r\n                        <div className='node node-finish'></div><p className=\"legend-item\"><b> Finish</b></p>\r\n                        <div className='node node-wall'></div><p className=\"legend-item\"><b> Wall</b></p>\r\n                        <div className='node node-weight'><div className='node-center'></div></div><p className=\"legend-item\"><b> Weight</b></p>\r\n                        <div className='node node-visited node-legend'></div><p className=\"legend-item\"><b> Visited</b></p>\r\n                        <div className='node node-shortest-path node-legend'></div><p className=\"legend-item\"><b> Path</b></p>\r\n                        <div className='node node-current node-legend'></div><p className=\"legend-item\"><b> Current</b></p>\r\n                        <div className='node node-legend'></div><p className=\"legend-item\"><b> Unvisited</b></p>\r\n                        <div className='node node-checkpoint node-legend'></div><p className=\"legend-item\"><b> Checkpoint</b></p>\r\n                        <div className='node node-checkpoint node-current node-legend'></div><p className=\"legend-item\"><b> Visited Checkpoint</b></p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import _ from \"lodash\";\r\n\r\nexport function animateAlgorithm(algoVisualizer, visitedNodesInOrderList, nodesInShortestPathOrderList) {\r\n    const delay = 10;\r\n    const shortestPathDelay = 25;\r\n    var numVisitedNodes = 0;\r\n    var numNodesInPath = 0;\r\n\r\n    numVisitedNodes += visitedNodesInOrderList.length;\r\n    for (let i = 0; i < visitedNodesInOrderList.length; i++) {\r\n        if (i === visitedNodesInOrderList.length - 1) {\r\n            numNodesInPath += new Set(nodesInShortestPathOrderList).size;\r\n            // Animate the shortest path\r\n            setTimeout(() => {\r\n                animateShortestPath(algoVisualizer, nodesInShortestPathOrderList, shortestPathDelay);\r\n            }, delay * i);\r\n        }\r\n        \r\n        setTimeout(() => {\r\n            const node = visitedNodesInOrderList[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the visted nodes\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-visited';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    algoVisualizer.setState({ numVisitedNodes, numNodesInPath });\r\n}\r\n\r\nfunction animateShortestPath(algoVisualizer, nodesInShortestPathOrder, delay=25) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            // Redraw element to restart animation on nodes with class node-shortest-path\r\n            var nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n            nodeElement.className = nodeElement.className.replace(\" node-shortest-path\", \"\");\r\n            setTimeout(()=>{nodeElement.className = nodeElement.className + ' node-shortest-path';}, 10);\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{algoVisualizer.setState({running: false});}, delay * nodesInShortestPathOrder.length);\r\n}\r\n\r\nexport function animateGeneration(algoVisualizer, generatedWallsInOrder, callback=null) {\r\n    const { grid } = algoVisualizer.state;\r\n    const delay = 10;\r\n    for (let i = 0; i < generatedWallsInOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = generatedWallsInOrder[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the walls\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-wall';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{\r\n        algoVisualizer.setState({running: false});\r\n        if(callback) callback(algoVisualizer, grid, generatedWallsInOrder);\r\n    }, delay * generatedWallsInOrder.length);\r\n}\r\n\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    var currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function sortNodesByDistance(nodes) {\r\n    nodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function sortNodesByDistanceAndHeuristic(nodes){\r\n    nodes.sort(function (nodeA, nodeB) {\r\n        // Sort on distance\r\n        if(nodeA.distance > nodeB.distance) {\r\n            return 1;\r\n        } else if (nodeA.distance < nodeB.distance) {\r\n            return -1;\r\n        } else {\r\n            // If the distances are the same,\r\n            // sort on distance - heuristic\r\n            if(nodeA.heuristic > nodeB.heuristic) {\r\n                return 1;\r\n            } else if (nodeA.heuristic < nodeB.heuristic) {\r\n                return -1;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function clearPath(algoVisualizer, callback=null) {\r\n    var { grid, checkpointNodes } = algoVisualizer.state;\r\n\r\n    // Mark checkpoint nodes as unvisited \r\n    for(let checkpointNodeInfo of checkpointNodes){\r\n        checkpointNodeInfo.isVisited = false;\r\n    }\r\n    \r\n    for(const row of grid) {\r\n        for(var node of row){\r\n            // update node values\r\n            var distance = node.type === \"startNode\" ? 0 : Infinity; \r\n            grid[node.row][node.col] = createNode(node.row, node.col, node.type, distance, node.text, node.weight);\r\n            // update css class\r\n            if(node.type === \"default\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n            } else if(node.type === \"checkpointNode\") {\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-checkpoint';\r\n            } else if(node.type === \"weightNode\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight';\r\n            }\r\n        }\r\n    }\r\n    algoVisualizer.setState({ grid, checkpointNodes, isPathDrawn: false, numNodesInPath: 0, numVisitedNodes: 0 }, callback);\r\n}\r\n\r\nexport function createNode(row, col, type, distance, text=\"\", weight=1) {\r\n    return {\r\n        row,\r\n        col,\r\n        type,\r\n        text,\r\n        distance,\r\n        weight,\r\n        heuristic: 0,\r\n        isVisited: false,\r\n        previousNode: null\r\n    }\r\n}\r\n\r\nexport function randomInteger(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function randomEvenInteger(min, max) {\r\n    var temp =(Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2;\r\n    return temp;\r\n}\r\n\r\nexport function randomOddInteger(min, max) {\r\n    var temp = (Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2 + 1;\r\n    return temp;\r\n}\r\n\r\nexport function resetGrid(algoVisualizer, callback) {\r\n    var { grid, startNodeCoords, finishNodeCoords } = algoVisualizer.state;\r\n\r\n    // reset node classnames\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n        }\r\n    }\r\n\r\n    // set start and finish node classnames\r\n    document.getElementById(`node-${startNodeCoords[0]}-${startNodeCoords[1]}`).className = 'node node-start';\r\n    document.getElementById(`node-${finishNodeCoords[0]}-${finishNodeCoords[1]}`).className = 'node node-finish';\r\n    grid = getInitialGrid(algoVisualizer);\r\n    algoVisualizer.setState({ grid, numWeights: 0, numWalls: 0, numNodesInPath: 0, numVisitedNodes: 0, checkpointNodes: [] }, callback);\r\n}\r\n\r\nexport function getInitialGrid(algoVisualizer){\r\n    // Generate the empty grid\r\n    const grid = [];\r\n    const nodesPerRow = 20;\r\n    const nodesPerCol = 50;\r\n    for (let row = 0; row < nodesPerRow; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < nodesPerCol; col++) {\r\n            currentRow.push(createNode(row, col, \"default\", Infinity));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    // Set the start and finish nodes\r\n    const [startRow, startCol] = algoVisualizer.state.startNodeCoords;\r\n    const [finishRow, finishCol] = algoVisualizer.state.finishNodeCoords;\r\n    grid[startRow][startCol] = createNode(startRow, startCol, \"startNode\", 0);\r\n    grid[finishRow][finishCol] = createNode(finishRow, finishCol, \"finishNode\", Infinity);\r\n    return grid;\r\n};\r\n\r\nexport function getEuclideanDistance(x1, y1, x2, y2){\r\n    var a = x1 - x2;\r\n    var b = y1 - y2;\r\n    return Math.sqrt( a*a + b*b );\r\n}\r\n\r\nexport function getRandomEmptyNodeCoords(algoVisualizer){\r\n    var { grid } = algoVisualizer.state;\r\n    var emptyNodes = [];\r\n    // Get all empty nodes\r\n    for(var row of grid){\r\n        var newRow = row.filter(node => node.type === \"default\");\r\n        if(newRow.length > 0) emptyNodes.push(newRow);\r\n    }\r\n\r\n    if(emptyNodes.length > 0) {\r\n        var nodeRow = randomInteger(0, emptyNodes.length - 1);\r\n        var node = emptyNodes[nodeRow][randomInteger(0, emptyNodes[nodeRow].length - 1)];\r\n        return [node.row, node.col];\r\n    }\r\n}\r\n\r\nexport function visualizAlgorithm(computeAlgorithm, lastAlgoRunString, algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    var startTime, runTimeSeconds, destinationNodeInfo, gridCopy, startNode, finishNode;\r\n    var originalStartNodeCoords = algoVisualizer.state.startNodeCoords;\r\n    var visitedNodesInOrder = [];\r\n    var nodesInShortestPathOrder = [];\r\n    var checkpointNodes = algoVisualizer.state.checkpointNodes;\r\n    var isPathPossible = true;\r\n    var shortestPath = [];\r\n    checkpointNodes.sort((nodeA, nodeB) => nodeA.id - nodeB.id);\r\n\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    // Reset the checkpoint nodes\r\n    for(var checkpointNodeInfo of checkpointNodes) {\r\n        checkpointNodeInfo.isVisited = false;\r\n        checkpointNodeInfo.distance = Infinity;\r\n    }\r\n\r\n    while(algoVisualizer.getDestinationNodeInfo().coords !== finishNodeCoords) {\r\n        destinationNodeInfo = algoVisualizer.getDestinationNodeInfo();\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        gridCopy[startNodeCoords[0]][startNodeCoords[1]].distance = 0;\r\n        if(lastAlgoRunString === \"DFS\") {\r\n            startNode = gridCopy[startNodeCoords[0]][startNodeCoords[1]];\r\n            finishNode = gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]];\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNode, finishNode, [])[1]);\r\n        } else {\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNodeCoords, destinationNodeInfo.coords));\r\n        }\r\n        shortestPath = getNodesInShortestPathOrder(gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]])\r\n        nodesInShortestPathOrder.push(shortestPath);\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        startNodeCoords = destinationNodeInfo.coords;\r\n        destinationNodeInfo.isVisited = true;\r\n        for(let checkpointNodeInfo of checkpointNodes) {\r\n            if(checkpointNodeInfo.id === destinationNodeInfo.id - 1) checkpointNodeInfo = destinationNodeInfo;\r\n        }\r\n\r\n        if(shortestPath.length <= 1) {\r\n            isPathPossible = false;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    if(isPathPossible) {\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        gridCopy[startNodeCoords[0]][startNodeCoords[1]].distance = 0;\r\n        if(lastAlgoRunString === \"DFS\") {\r\n            startNode = gridCopy[startNodeCoords[0]][startNodeCoords[1]];\r\n            finishNode = gridCopy[finishNodeCoords[0]][finishNodeCoords[1]];\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNode, finishNode, [])[1]);\r\n        } else {\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNodeCoords, finishNodeCoords));\r\n        }\r\n        nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[finishNodeCoords[0]][finishNodeCoords[1]]));\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        animateAlgorithm(algoVisualizer, visitedNodesInOrder.flat(), nodesInShortestPathOrder.flat());\r\n    } else {\r\n        animateAlgorithm(algoVisualizer, visitedNodesInOrder.flat(), []);\r\n    }\r\n\r\n    algoVisualizer.setState({ visitedNodesToAnimate: visitedNodesInOrder, pathNodesToAnimate: nodesInShortestPathOrder, checkpointNodes, isPathDrawn: true, runTimeSeconds, lastAlgoRunString});\r\n}","import { animateAlgorithm, sortNodesByDistance, getAllNodes, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeDijkstra(grid, startNodeCoords, finishNodeCoords) {\r\n  const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n  const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n  startNode.distance = 0;\r\n  var visitedNodes = [];\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while(unvisitedNodes.length){\r\n      // Sort the nodes by distance\r\n      sortNodesByDistance(unvisitedNodes);\r\n      // Get the closest unvisited node\r\n      var closestNode = unvisitedNodes.shift();\r\n      // unvisitedNodes.unshift();\r\n      // Skip if the closest node is a wall\r\n      if(closestNode.type === \"wallNode\") continue;\r\n      // Return if there are no possible routes\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n\r\n      // Check if the current node is the finish node\r\n      if(closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + neighbor.weight;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nexport function visualizeDijkstra(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n  algoVisualizer.setState({running: true});\r\n  clearPath(algoVisualizer);\r\n  var startTime = new Date().getTime();\r\n  const visitedNodesInOrder = computeDijkstra(grid, startNodeCoords, finishNodeCoords);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  var runTimeSeconds = new Date().getTime() - startTime;\r\n  animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n  algoVisualizer.setState({ isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"Dijkstra\" });\r\n}\r\n\r\n\r\n","import { animateAlgorithm, sortNodesByDistanceAndHeuristic, getAllNodes, getNeighbors, getNodesInShortestPathOrder, clearPath, getEuclideanDistance } from '../helpers.js';\r\nimport _ from \"lodash\";\r\n\r\nexport function computeAStar(grid, startNodeCoords, finishNodeCoords) {\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    grid = getGridWithHeuristics(grid, finishNode, \"manhattan\");\r\n    startNode.distance = 0;\r\n    var visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(unvisitedNodes.length){\r\n        // Sort the nodes by distance\r\n        sortNodesByDistanceAndHeuristic(unvisitedNodes);\r\n        // Get the closest unvisited node\r\n        var closestNode = unvisitedNodes.shift();\r\n        // Skip if the closest node is a wall\r\n        if(closestNode.type === \"wallNode\") continue;\r\n        // Return if there are no possible routes\r\n        if (closestNode.distance === Infinity) return visitedNodes;\r\n        closestNode.isVisited = true;\r\n        visitedNodes.push(closestNode);\r\n\r\n        // Check if the current node is the finish node\r\n        if(closestNode === finishNode) return visitedNodes;\r\n        updateneighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nexport function visualizeAStar(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    var startTime, runTimeSeconds, destinationNodeInfo, gridCopy;\r\n    var { originalStartNodeCoords, checkpointNodes } = algoVisualizer.state;\r\n    var visitedNodesInOrder = [];\r\n    var nodesInShortestPathOrder = [];\r\n\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n\r\n    while(algoVisualizer.getDestinationNodeInfo().coords !== finishNodeCoords) {\r\n        destinationNodeInfo = algoVisualizer.getDestinationNodeInfo();\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        visitedNodesInOrder.push(computeAStar(gridCopy, startNodeCoords, destinationNodeInfo.coords));\r\n        nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]]));\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        startNodeCoords = destinationNodeInfo.coords;\r\n        destinationNodeInfo.isVisited = true;\r\n        checkpointNodes[destinationNodeInfo.id - 1] = destinationNodeInfo;\r\n    }\r\n    \r\n    startTime = new Date().getTime();\r\n    gridCopy = _.cloneDeep(grid);\r\n    visitedNodesInOrder.push(computeAStar(gridCopy, startNodeCoords, finishNodeCoords));\r\n    nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[finishNodeCoords[0]][finishNodeCoords[1]]));\r\n    runTimeSeconds = new Date().getTime() - startTime;\r\n\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({visitedNodesToAnimate: visitedNodesInOrder, pathNodesToAnimate: nodesInShortestPathOrder, checkpointNodes, isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"A*\"});\r\n}\r\n\r\nfunction updateneighbors(node, grid) {\r\n    const neighbors = getNeighbors(node, grid);\r\n    for (const neighbor of neighbors) {\r\n        if(neighbor.isVisited){\r\n            if(neighbor.distance - neighbor.heuristic < node.previousNode.distance - node.previousNode.heuristic){\r\n                node.previousNode = neighbor;\r\n            }\r\n        } else {\r\n            if(node.distance === 0){\r\n                neighbor.distance = neighbor.weight + neighbor.heuristic; \r\n            } else {\r\n                neighbor.distance = node.distance - node.heuristic + neighbor.weight + neighbor.heuristic;\r\n            }\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getGridWithHeuristics(grid, finishNode, heuristic=\"manhattan\"){\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            if(heuristic === \"manhattan\"){\r\n                // Manhattan distance heuristic\r\n                node.heuristic = Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col);\r\n            } else if(heuristic === \"euclidean\") {\r\n                // Euclidean distance \r\n                node.heuristic = getEuclideanDistance(node.row, node.col, finishNode.row, finishNode.col);\r\n            }\r\n        }\r\n    }\r\n    return grid;\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeDFS(grid, currentNode, finishNode, visitedNodes) {\r\n    visitedNodes.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) return [visitedNodes, visitedNodes];\r\n    for(let unvisitedNeighbor of getUnvisitedNeighbors(currentNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")) {\r\n        if(!unvisitedNeighbor.isVisited){\r\n            unvisitedNeighbor.previousNode = currentNode;\r\n            var newVisitedNodes = computeDFS(grid, unvisitedNeighbor, finishNode, visitedNodes)[0];\r\n            if(newVisitedNodes) return [newVisitedNodes, newVisitedNodes];\r\n        }\r\n    }\r\n    return [null, visitedNodes];\r\n}\r\n\r\nexport function visualizeDFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeDFS(grid, startNode, finishNode, [])[1];\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    if(visitedNodesInOrder) animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder); else algoVisualizer.setState({running: false});\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"DFS\"});\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeBFS(grid, startNodeCoords, finishNodeCoords) {\r\n    var startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    var finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var queue = [startNode];\r\n    var path = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    if(startNode === finishNode) return path;\r\n\r\n    while(queue){\r\n        startNode = queue.shift();\r\n\r\n        if(startNode){\r\n            for(var neighbor of getUnvisitedNeighbors(startNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")){\r\n                if(!path.includes(neighbor)){\r\n                    neighbor.previousNode = startNode;\r\n                    neighbor.isVisited = true;\r\n                    path.push(neighbor);\r\n                    queue.push(neighbor);\r\n    \r\n                    if(neighbor === finishNode) return path;\r\n                }\r\n            }\r\n        } else {\r\n            return path;\r\n        }\r\n\r\n    }\r\n    return path;\r\n}\r\n\r\nexport function visualizeBFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeBFS(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"BFS\"});\r\n}","import {resetGrid, randomInteger, animateGeneration} from '../helpers';\r\n\r\nexport function computeRecursiveDivision(chamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder){\r\n    \r\n    const min_chamber_size = 2;\r\n    var wallLineRow, wallLineCol, entranceIdx;\r\n\r\n    // If minimum chamber size is reached, return the generated walls\r\n    if(chamber.length <= min_chamber_size && chamber[0].length <= min_chamber_size ){\r\n        return generatedWallsInOrder;\r\n    }\r\n\r\n    // Create the outer walls\r\n    if(generatedWallsInOrder.length === 0) {\r\n        for(let row = 0; row < chamber.length; row++){\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(row === 0 || col === 0 || row === chamber.length - 1 || col === chamber[0].length - 1 ){\r\n                    if(chamber[row][col].type !== \"startNode\" && chamber[row][col].type !== \"finishNode\") generatedWallsInOrder.push(chamber[row][col]);\r\n                }\r\n            }\r\n        }\r\n        chamber = chamber.slice(1, chamber.length - 1);\r\n        for(let row = 0; row < chamber.length; row++){\r\n            chamber[row] = chamber[row].slice(1, chamber[row].length - 1);\r\n        }\r\n    }\r\n\r\n    // Divide chamber horizonally if the chamber is more tall than wide\r\n    if(chamber.length > chamber[0].length){\r\n        // Select a random row within the chamber to draw walls. \r\n        // Leave a one row space to prevent a double wall\r\n        wallLineRow = randomInteger(1, chamber.length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber[0].length - 1;\r\n        // Add walls along that row\r\n        for(var col = 0; col < chamber[wallLineRow].length; col++){\r\n            if(col !== entranceIdx && chamber[wallLineRow][col] && chamber[wallLineRow][col].type !== \"startNode\" && chamber[wallLineRow][col].type !== \"finishNode\") generatedWallsInOrder.push(chamber[wallLineRow][col]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newTopChamber = [];\r\n        var newBottomChamber = [];\r\n        for(let row = 0; row < chamber.length; row++){\r\n            const currentRowTopChamber = [];\r\n            const currentRowBottomChamber = [];\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(row < wallLineRow) currentRowTopChamber.push(chamber[row][col]);\r\n                if(row > wallLineRow) currentRowBottomChamber.push(chamber[row][col]); \r\n            }\r\n            if(currentRowTopChamber.length !== 0) newTopChamber.push(currentRowTopChamber);\r\n            if(currentRowBottomChamber.length !== 0) newBottomChamber.push(currentRowBottomChamber);\r\n            \r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newTopChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newBottomChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n\r\n    } else {\r\n        // Select a random col within the chamber to draw walls. \r\n        // Leave a one col space to prevent a double wall\r\n        wallLineCol = randomInteger(1, chamber[0].length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber.length - 1;\r\n        // Add walls along that col\r\n        for(let row = 0; row < chamber.length; row++){\r\n            if(row !== entranceIdx && chamber[row][wallLineCol] && chamber[row][wallLineCol].type !== \"startNode\" && chamber[row][wallLineCol].type !== \"finishNode\") generatedWallsInOrder.push(chamber[row][wallLineCol]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newLeftChamber = [];\r\n        var newRightChamber = [];\r\n        for(let row = 0; row < chamber.length; row++){\r\n            const currentRowLeftChamber = [];\r\n            const currentRowRightChamber = [];\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(col < wallLineCol) currentRowLeftChamber.push(chamber[row][col]);\r\n                if(col > wallLineCol) currentRowRightChamber.push(chamber[row][col]);\r\n            }\r\n            newLeftChamber.push(currentRowLeftChamber);\r\n            newRightChamber.push(currentRowRightChamber);\r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newLeftChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newRightChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n    }\r\n\r\n    return generatedWallsInOrder;\r\n}\r\n\r\nexport function visualizeRecursiveDivision(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    resetGrid(algoVisualizer, ()=>{\r\n        var startTime = new Date().getTime();\r\n        // Get the generated walls in order\r\n        const generatedWallsInOrder = computeRecursiveDivision(grid, startNodeCoords, finishNodeCoords, []);\r\n        var runTimeSeconds = new Date().getTime() - startTime;\r\n        algoVisualizer.setState({ runTimeSeconds, lastAlgoRunString: \"Recursive Division\" });\r\n        animateGeneration(algoVisualizer, generatedWallsInOrder, setWalls);\r\n    });\r\n}\r\n\r\nfunction setWalls(algoVisualizer, grid, walls){\r\n    for(var node of walls){\r\n        const newNode = {\r\n            ...node,\r\n            type: \"wallNode\"\r\n            };\r\n        grid[node.row][node.col] = newNode;\r\n    }\r\n    algoVisualizer.setState({ grid, numWalls: walls.length });\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport Stats from './Stats/Stats';\r\nimport Legend from './Legend/Legend';\r\n\r\nimport {computeDijkstra} from '../Algorithms/Search/dijkstra';\r\nimport {computeAStar} from '../Algorithms/Search/aStar';\r\nimport {computeDFS} from '../Algorithms/Search/dfs';\r\nimport {computeBFS} from '../Algorithms/Search/bfs';\r\nimport {getInitialGrid, resetGrid, clearPath, createNode, randomInteger, getRandomEmptyNodeCoords, visualizAlgorithm} from '../Algorithms/helpers';\r\nimport './AlgoVisualizer.css';  \r\nimport { visualizeRecursiveDivision } from '../Algorithms/Generator/recursiveDivision';\r\n\r\nexport default class AlgoVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            startNodeCoords: [5, 10],\r\n            finishNodeCoords: [7, 40],\r\n            checkpointNodes: [],\r\n            draggingCheckpointNodeInfo: {},\r\n            running: false,\r\n            dragging: \"\",\r\n            isPathDrawn: false,\r\n            lastAlgoRunString: \"\",\r\n            runTimeSeconds: 0,\r\n            numNodesInPath: 0,\r\n            numVisitedNodes: 0,\r\n            numWalls: 0,\r\n            numWeights: 0,\r\n            weight: 5,\r\n            drawMode: \"wall\"\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = getInitialGrid(this);\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        var type = this.state.grid[row][col].type;\r\n        var { drawMode, running, grid, numWalls, numWeights, weight, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n        var newGrid;\r\n        var nodeType = \"default\";\r\n\r\n        if(running) return; \r\n\r\n        if([\"wallNode\", \"weightNode\", \"default\"].includes(type)) {\r\n            if(type === \"wallNode\") numWalls -= 1;\r\n            if(type === \"weightNode\") numWeights -= 1;\r\n\r\n            if(drawMode === \"weight\") {\r\n                if([\"default\", \"wallNode\"].includes(type)) {\r\n                    numWeights += 1;\r\n                    nodeType = \"weightNode\";\r\n                }\r\n                newGrid = getNodeUpdatedGrid(grid, row, col, nodeType, \"\", weight);\r\n            }\r\n            if(drawMode === \"wall\") {\r\n                if([\"default\", \"weightNode\"].includes(type)) numWalls += 1;\r\n                newGrid = getWallUpdatedGrid(grid, row, col);\r\n            }\r\n            this.setState({ grid: newGrid, dragging: type, numWalls, numWeights });\r\n        } else if (type === \"checkpointNode\") {\r\n            // Keep track of which checkpoiontNode is being dragged\r\n            checkpointNodes.forEach(checkpointNodeInfo => {\r\n                if (checkpointNodeInfo.coords[0] === row && checkpointNodeInfo.coords[1] === col) {\r\n                    draggingCheckpointNodeInfo = checkpointNodeInfo;\r\n                }\r\n            });\r\n            this.setState({ dragging: type, draggingCheckpointNodeInfo });\r\n        } else {\r\n            this.setState({ dragging: type });\r\n        }\r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        var { grid, running, dragging, drawMode, weight, numWalls, numWeights, startNodeCoords, finishNodeCoords, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n        const enteredNodeType = grid[row][col].type;\r\n        var enteredNodeID = \"\";\r\n        var newGrid = grid;\r\n        var nodeType = \"\";\r\n\r\n        if(running || dragging === \"\") return;\r\n\r\n        if([\"startNode\", \"finishNode\", \"checkpointNode\"].includes(dragging)) {\r\n            newGrid = dragging === \"checkpointNode\" \r\n                ? getNodeUpdatedGrid(newGrid, row, col, dragging, draggingCheckpointNodeInfo.id)\r\n                : getNodeUpdatedGrid(newGrid, row, col, dragging);\r\n\r\n            if(enteredNodeType === \"wallNode\") {\r\n                numWalls -= 1;\r\n            } else {\r\n                const randomEmptyNodeCoords = getRandomEmptyNodeCoords(this);\r\n                if(enteredNodeType === \"finishNode\") {\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"finishNode\");\r\n                    finishNodeCoords = randomEmptyNodeCoords;\r\n                } else if(enteredNodeType === \"startNode\") {\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"startNode\");\r\n                    startNodeCoords = randomEmptyNodeCoords;\r\n                } else if(enteredNodeType === \"checkpointNode\") {\r\n                    // Update checkpointNode state\r\n                    checkpointNodes.forEach(checkpointNodeInfo => {\r\n                        if(checkpointNodeInfo.coords[0] === row && checkpointNodeInfo.coords[1] === col) {\r\n                            checkpointNodeInfo.coords = randomEmptyNodeCoords;\r\n                            enteredNodeID = checkpointNodeInfo.id;\r\n                        }\r\n                    });\r\n                    draggingCheckpointNodeInfo.coords = [row, col];\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"checkpointNode\", enteredNodeID);\r\n                }\r\n            }\r\n        } else {\r\n            if(drawMode === \"wall\") {\r\n                numWalls = enteredNodeType === \"wallNode\" ? numWalls - 1 : numWalls + 1;\r\n                newGrid = getWallUpdatedGrid(newGrid, row, col);\r\n            }else if(drawMode === \"weight\") {\r\n                if(enteredNodeType === \"weightNode\") {\r\n                    numWeights -= 1;\r\n                    nodeType = \"default\";\r\n                    weight = 1;\r\n                } else {\r\n                    if(enteredNodeType === \"wallNode\") numWalls -= 1;\r\n                    numWeights += 1;\r\n                    nodeType = \"weightNode\";\r\n                }\r\n                newGrid = getNodeUpdatedGrid(newGrid, row, col, nodeType, \"\", weight);\r\n            }\r\n        }\r\n        this.setState({ grid: newGrid, numWalls, numWeights, startNodeCoords, finishNodeCoords, checkpointNodes, draggingCheckpointNodeInfo });\r\n    }\r\n    \r\n    handleMouseLeave(row, col){\r\n        if(this.state.running) return;\r\n        if([\"startNode\", \"finishNode\", \"checkpointNode\"].includes(this.state.dragging)){\r\n            if(this.state.isPathDrawn) clearPath(this);\r\n            this.setState({ grid: getNodeUpdatedGrid(this.state.grid, row, col, \"default\") });\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        var { running, grid, dragging, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n        if(running) return;\r\n        if(dragging === \"startNode\"){\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"startNode\");\r\n            this.setState({ grid: newGrid, dragging: \"\", startNodeCoords: [row, col] });\r\n        } else if(dragging === \"finishNode\") {\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"finishNode\");\r\n            this.setState({ grid: newGrid, dragging: \"\", finishNodeCoords: [row, col] });\r\n        } else if(dragging === \"checkpointNode\") {\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"checkpointNode\", draggingCheckpointNodeInfo.id);\r\n            checkpointNodes.forEach(checkpointNodeInfo => {\r\n                if(checkpointNodeInfo.id === draggingCheckpointNodeInfo.id) checkpointNodeInfo.coords = [row, col];\r\n            });\r\n            this.setState({ grid: newGrid, dragging: \"\", checkpointNodes });\r\n        }\r\n        this.setState({ dragging: \"\" });\r\n    }\r\n  \r\n    getEmptyNodes(grid) {\r\n        var emptyNodes = [];\r\n        // Get all empty nodes\r\n        for(var row of grid){\r\n            var newRow = row.filter(node => node.type === \"default\");\r\n            if(newRow.length > 0) emptyNodes.push(newRow);\r\n        }\r\n        return emptyNodes;\r\n    }\r\n\r\n    randomizeStartFinishNodes() {\r\n        var {grid, startNodeCoords, finishNodeCoords } = this.state;\r\n        \r\n        grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"default\", Infinity);\r\n        grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"default\", Infinity);\r\n        \r\n        // Get all empty nodes\r\n        var emptyNodes = this.getEmptyNodes(grid);\r\n\r\n        if(emptyNodes.length > 0) {\r\n            var startNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var startNode = emptyNodes[startNodeRow][randomInteger(0, emptyNodes[startNodeRow].length - 1)];\r\n            var finishNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var finishNode = emptyNodes[finishNodeRow][randomInteger(0, emptyNodes[finishNodeRow].length - 1)];\r\n    \r\n            startNodeCoords = [startNode.row, startNode.col];\r\n            finishNodeCoords = [finishNode.row, finishNode.col];\r\n            \r\n            grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"startNode\", 0);\r\n            grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"finishNode\", Infinity);\r\n            \r\n            this.setState({ grid, startNodeCoords, finishNodeCoords });\r\n        }\r\n    }\r\n\r\n    addCheckpointNode(){\r\n        var { grid, checkpointNodes, isPathDrawn } = this.state;\r\n\r\n        // If there is a path, clear it and mark checkpoints as unvisited \r\n        if(isPathDrawn) clearPath(this);\r\n        \r\n        // Get all empty nodes\r\n        var emptyNodes = this.getEmptyNodes(grid);\r\n\r\n        // If there is empty space, add a checkpoint node\r\n        if(emptyNodes.length > 0) {\r\n            var checkpointNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var checkpointNode = emptyNodes[checkpointNodeRow][randomInteger(0, emptyNodes[checkpointNodeRow].length - 1)];\r\n            var checkpointNodeCoords = [checkpointNode.row, checkpointNode.col];\r\n            var checkpointNodeInfo = {\r\n                id:checkpointNodes.length + 1,\r\n                coords:checkpointNodeCoords,\r\n                isVisited:false\r\n            };\r\n    \r\n            grid[checkpointNodeCoords[0]][checkpointNodeCoords[1]] = createNode(checkpointNodeCoords[0], checkpointNodeCoords[1], \"checkpointNode\", Infinity, checkpointNodeInfo.id);\r\n            \r\n            checkpointNodes.push(checkpointNodeInfo);\r\n            // Update the state\r\n            this.setState({ grid, checkpointNodes });\r\n        }\r\n    }\r\n\r\n    toggleNodeDrawType(){\r\n        this.setState({ drawMode: this.state.drawMode === \"wall\" ? \"weight\" : \"wall\" });\r\n    }\r\n\r\n    getDestinationNodeInfo() {\r\n        var { checkpointNodes, finishNodeCoords } = this.state;\r\n        for(var checkpointNodeInfo of checkpointNodes.reverse()) {\r\n            if(!checkpointNodeInfo.isVisited) return checkpointNodeInfo;\r\n        }\r\n\r\n        return {id:0, coords:finishNodeCoords, isVisited: false};\r\n    }\r\n\r\n    render() {\r\n        const {grid, startNodeCoords, finishNodeCoords, runTimeSeconds, numNodesInPath, numVisitedNodes, numWalls, numWeights, weight, lastAlgoRunString} = this.state;\r\n\r\n        return (\r\n            <div className='body'>\r\n                <div className='menu'>\r\n                    <h1 className='title'>Pathfinding Visualizer</h1>\r\n                    <div className='menu-group-container'>\r\n                        <div className='menu-group'>\r\n                            <h2>Pathfinding</h2>\r\n                            <div className='menu-subgroup'>\r\n                                <h3>Weighted</h3>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeDijkstra, \"Dijkstra\", this, grid, startNodeCoords, finishNodeCoords)}>Dijkstra</button>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeAStar, \"A*\", this, grid, startNodeCoords, finishNodeCoords)}>A*</button>\r\n                            </div>\r\n                            <div className='menu-subgroup'>\r\n                                <h3>Unweighted</h3>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeDFS, \"DFS\", this, grid, startNodeCoords, finishNodeCoords)}>DFS</button>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeBFS, \"BFS\", this, grid, startNodeCoords, finishNodeCoords)}>BFS</button>\r\n                            </div>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Generators</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeRecursiveDivision(this, grid, startNodeCoords, finishNodeCoords)}>Recursive Division</button>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Board Options</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> this.addCheckpointNode()}>Add checkpoint</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> this.toggleNodeDrawType()}>Draw: {this.state.drawMode}</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> resetGrid(this)}>Clear Board</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this)}>Clear Path</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this, this.randomizeStartFinishNodes)}>Randomize Start and End Nodes</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"grid-container\">\r\n                    <Legend></Legend>\r\n                    <Stats\r\n                        runTimeSeconds={runTimeSeconds}\r\n                        numNodesInPath={numNodesInPath}\r\n                        numVisitedNodes={numVisitedNodes}\r\n                        numWalls={numWalls}\r\n                        numWeights={numWeights}\r\n                        weightValue={weight}\r\n                        lastAlgoRunString={lastAlgoRunString}\r\n                        ></Stats>\r\n                    <div className=\"grid\">\r\n                        {grid.map((row, rowIdx) => {\r\n                            return (\r\n                                <div key={rowIdx}>\r\n                                    {row.map((node, nodeIdx) => {\r\n                                        const { row, col, type, distance, text, weight } = node;\r\n                                        return (\r\n                                            <Node\r\n                                                key={nodeIdx}\r\n                                                className='node'\r\n                                                row={row}\r\n                                                col={col}\r\n                                                type={type}\r\n                                                text={text}\r\n                                                weight={weight}\r\n                                                distance={distance}\r\n                                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                                onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                                                onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\r\n                                            ></Node>);\r\n                                    })}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                </div>\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction getWallUpdatedGrid(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        type: node.type === \"wallNode\" ? \"default\" : node.type === \"default\" || node.type === \"weightNode\" ? \"wallNode\" : node.type\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\nfunction getNodeUpdatedGrid(grid, row, col, type, text=\"\", weight=1) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    var newNode = {\r\n        ...node,\r\n        weight,\r\n        text,\r\n        type\r\n    };\r\n\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport AlgoVisuaizer from './AlgoVisualizer/AlgoVisualizer';\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <AlgoVisuaizer></AlgoVisuaizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}