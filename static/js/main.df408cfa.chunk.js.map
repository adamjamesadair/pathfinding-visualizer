{"version":3,"sources":["AlgoVisualizer/Node/Node.jsx","Algorithms/helpers.js","Algorithms/dijkstra.js","Algorithms/aStar.js","Algorithms/dfs.js","Algorithms/bfs.js","AlgoVisualizer/AlgoVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","row","col","type","onMouseDown","onMouseEnter","onMouseUp","typeClass","id","className","Component","animateAlgorithm","visitedNodesInOrder","nodesInShortestPathOrder","i","length","setTimeout","node","document","getElementById","animateShortestPath","oldClasses","getAllNodes","grid","nodes","push","getUnvisitedNeighbors","neighbors","filter","neighbor","isVisited","getNodesInShortestPathOrder","finishNode","currentNode","unshift","previousNode","sortNodesByDistance","sort","nodeA","nodeB","distance","clearPath","algoVisualizer","Infinity","createNode","setState","updateUnvisitedNeighbors","unvisitedNeighbors","visualizeDijkstra","algoVisualiser","startNodeCoords","finishNodeCoords","startNode","visitedNodes","unvisitedNodes","closestNode","shift","computeDijkstra","visualizeAStar","computeAStar","manhattanDistance","Math","abs","visualizeDFS","computeDFS","unvisitedNeighbor","newVisitedNodes","visualizeBFS","queue","path","includes","computeBFS","AlgoVisualizer","mouseIsPressed","getInitialGrid","newGrid","getWallUpdatedGrid","callback","randomInteger","onClick","resetGrid","randomizeStartFinishNodes","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","currentRow","startRow","startCol","finishRow","finishCol","slice","newNode","min","max","floor","random","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.df408cfa.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            type,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp\r\n        } = this.props;\r\n\r\n        const typeClass = type === \"finishNode\"\r\n            ? 'node-finish'\r\n            : type === \"startNode\"\r\n            ? 'node-start'\r\n            : type === \"wallNode\"\r\n            ? 'node-wall'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className = {`node ${typeClass}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","export function animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n  for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n          setTimeout(() => {\r\n              animateShortestPath(nodesInShortestPathOrder);\r\n          }, 10 * i);\r\n          return;\r\n      }\r\n      \r\n      setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n          var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n          setTimeout(()=>{\r\n              document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-visited';\r\n          }, 10);\r\n      }, 10 * i);\r\n  }\r\n}\r\n\r\nfunction animateShortestPath(nodesInShortestPathOrder) {\r\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          document.getElementById(`node-${node.row}-${node.col}`).className = \r\n          document.getElementById(`node-${node.row}-${node.col}`).className + ' node-shortest-path';\r\n      }, 50 * i);\r\n  }\r\n}\r\n\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  var currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function sortNodesByDistance(nodes) {\r\n    nodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function clearPath(algoVisualizer) {\r\n        var {grid} = algoVisualizer.state;\r\n        \r\n        for(const row of grid) {\r\n            for(var node of row){\r\n                // update node values\r\n                var distance = node.type === \"startNode\" ? 0 : Infinity; \r\n                grid[node.row][node.col] = createNode(node.row, node.col, node.type, distance);\r\n                // update css class\r\n                if(node.type === \"default\"){\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n                }\r\n            }\r\n        }\r\n        algoVisualizer.setState({ grid });\r\n    }\r\n\r\nexport function createNode(row, col, type, distance) {\r\n    return {\r\n        row,\r\n        col,\r\n        type,\r\n        distance,\r\n        isVisited: false,\r\n        previousNode: null\r\n    }\r\n}","import { animateAlgorithm, sortNodesByDistance, getAllNodes, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from './helpers.js';\r\n\r\nexport function computeDijkstra(grid, startNodeCoords, finishNodeCoords) {\r\n  const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n  const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n  startNode.distance = 0;\r\n  var visitedNodes = [];\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while(unvisitedNodes.length){\r\n      // Sort the nodes by distance\r\n      sortNodesByDistance(unvisitedNodes);\r\n      // Get the closest unvisited node\r\n      var closestNode = unvisitedNodes.shift();\r\n      // unvisitedNodes.unshift();\r\n      // Skip if the closest node is a wall\r\n      if(closestNode.type === \"wallNode\") continue;\r\n      // Return if there are no possible routes\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n\r\n      // Check if the current node is the finish node\r\n      if(closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nexport function visualizeDijkstra(algoVisualiser, grid, startNodeCoords, finishNodeCoords) {\r\n  clearPath(algoVisualiser);\r\n  const visitedNodesInOrder = computeDijkstra(grid, startNodeCoords, finishNodeCoords);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n}\r\n\r\n\r\n","import { animateAlgorithm, sortNodesByDistance, getAllNodes, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from './helpers.js';\r\n\r\nexport function computeAStar(grid, startNodeCoords, finishNodeCoords) {\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    startNode.distance = 0;\r\n    var visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(unvisitedNodes.length){\r\n        // Sort the nodes by distance\r\n        sortNodesByDistance(unvisitedNodes);\r\n        // Get the closest unvisited node\r\n        var closestNode = unvisitedNodes.shift();\r\n        // unvisitedNodes.unshift();\r\n        // Skip if the closest node is a wall\r\n        if(closestNode.type === \"wallNode\") continue;\r\n        // Return if there are no possible routes\r\n        if (closestNode.distance === Infinity) return visitedNodes;\r\n        closestNode.isVisited = true;\r\n        visitedNodes.push(closestNode);\r\n\r\n        // Check if the current node is the finish node\r\n        if(closestNode === finishNode) return visitedNodes;\r\n        updateUnvisitedNeighbors(closestNode, grid, finishNode);\r\n    }\r\n}\r\n\r\nexport function visualizeAStar(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n  clearPath(algoVisualizer);\r\n  const visitedNodesInOrder = computeAStar(grid, startNodeCoords, finishNodeCoords);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid, finishNode) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    // Manhattan distance heuristic\r\n    var manhattanDistance = Math.abs(neighbor.row - finishNode.row) + Math.abs(neighbor.col - finishNode.col);\r\n    neighbor.distance = manhattanDistance;\r\n    neighbor.previousNode = node;\r\n  }\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from './helpers.js';\r\n\r\nfunction computeDFS(grid, currentNode, finishNode, visitedNodes) {\r\n    visitedNodes.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) return visitedNodes;\r\n    for(let unvisitedNeighbor of getUnvisitedNeighbors(currentNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")) {\r\n        if(!unvisitedNeighbor.isVisited){\r\n            unvisitedNeighbor.previousNode = currentNode;\r\n            var newVisitedNodes = computeDFS(grid, unvisitedNeighbor, finishNode, visitedNodes);\r\n            if(newVisitedNodes)return newVisitedNodes;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\nexport function visualizeDFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n  clearPath(algoVisualizer);\r\n  const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n  const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n  const visitedNodesInOrder = computeDFS(grid, startNode, finishNode, []);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from './helpers.js';\r\n\r\nfunction computeBFS(grid, startNode, finishNode) {\r\n    var queue = [startNode];\r\n    var path = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    if(startNode === finishNode) return path;\r\n\r\n    while(queue){\r\n        startNode = queue.shift();\r\n\r\n        for(var neighbor of getUnvisitedNeighbors(startNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")){\r\n            if(!path.includes(neighbor)){\r\n                neighbor.previousNode = startNode;\r\n                neighbor.isVisited = true;\r\n                path.push(neighbor);\r\n                queue.push(neighbor);\r\n\r\n                if(neighbor === finishNode) return path;\r\n            }\r\n        }\r\n    }\r\n    return path;\r\n}\r\n\r\nexport function visualizeBFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n  clearPath(algoVisualizer);\r\n  const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n  const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n  const visitedNodesInOrder = computeBFS(grid, startNode, finishNode);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\n\r\nimport {visualizeDijkstra} from '../Algorithms/dijkstra';\r\nimport {visualizeAStar} from '../Algorithms/aStar';\r\nimport {visualizeDFS} from '../Algorithms/dfs';\r\nimport {visualizeBFS} from '../Algorithms/bfs';\r\nimport {clearPath, createNode} from '../Algorithms/helpers';\r\nimport './AlgoVisualizer.css';  \r\n\r\nexport default class AlgoVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            startNodeCoords: [5, 10],\r\n            finishNodeCoords: [7, 40],\r\n            mouseIsPressed: false\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = getInitialGrid(this.state);\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        const newGrid = getWallUpdatedGrid(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed) return;\r\n        const newGrid = getWallUpdatedGrid(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid });\r\n    }\r\n    \r\n    handleMouseUp() {\r\n        this.setState({ mouseIsPressed: false });\r\n    }\r\n    \r\n    resetGrid(callback) {\r\n        var {grid, startNodeCoords, finishNodeCoords} = this.state;\r\n\r\n        // reset node classnames\r\n        for (const row of grid) {\r\n            for (const node of row) {\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n            }\r\n        }\r\n\r\n        // set start and finish node classnames\r\n        document.getElementById(`node-${startNodeCoords[0]}-${startNodeCoords[1]}`).className = 'node node-start';\r\n        document.getElementById(`node-${finishNodeCoords[0]}-${finishNodeCoords[1]}`).className = 'node node-finish';\r\n        grid = getInitialGrid(this.state);\r\n        this.setState({ grid }, callback);\r\n    }\r\n\r\n    randomizeStartFinishNodes() {\r\n        var {grid, startNodeCoords, finishNodeCoords } = this.state;\r\n        \r\n        grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"default\", Infinity);\r\n        grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"default\", Infinity);\r\n        \r\n        startNodeCoords = [randomInteger(0, grid.length - 1), randomInteger(0, grid[0].length - 1)];\r\n        finishNodeCoords = [randomInteger(0, grid.length - 1), randomInteger(0, grid[0].length - 1)];\r\n        \r\n        grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"startNode\", 0);\r\n        grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"finishNode\", Infinity);\r\n        \r\n        this.setState({ grid, startNodeCoords, finishNodeCoords });\r\n    }\r\n\r\n    render() {\r\n        const {grid, startNodeCoords, finishNodeCoords} = this.state;\r\n\r\n        return (\r\n            <div>\r\n                <h1>Pathfinding Visualizer</h1>\r\n                <div className='menu'>\r\n                    <button className=\"btn btn-outline-dark\" onClick={() => visualizeDijkstra(this, grid, startNodeCoords, finishNodeCoords)}>Dijkstra's Algorithm</button>\r\n                    <button className=\"btn btn-outline-dark\" onClick={() => visualizeAStar(this, grid, startNodeCoords, finishNodeCoords)}>A*</button>\r\n                    <button className=\"btn btn-outline-dark\" onClick={() => visualizeDFS(this, grid, startNodeCoords, finishNodeCoords)}>DFS</button>\r\n                    <button className=\"btn btn-outline-dark\" onClick={() => visualizeBFS(this, grid, startNodeCoords, finishNodeCoords)}>BFS</button>\r\n                </div>\r\n                <div className='menu'>\r\n                    <button className=\"btn btn-outline-dark\" onClick={()=> this.resetGrid()}>Reset</button>\r\n                    <button className=\"btn btn-outline-dark\" onClick={()=> clearPath(this)}>Clear Path</button>\r\n                    <button className=\"btn btn-outline-dark\" onClick={()=> this.resetGrid(this.randomizeStartFinishNodes)}>Randomize Start and End Nodes</button>\r\n                </div>\r\n\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, type, distance } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            className='node'\r\n                                            row={row}\r\n                                            col={col}\r\n                                            type={type}\r\n                                            distance={distance}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) =>\r\n                                                this.handleMouseEnter(row, col)\r\n                                            }\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n                                        >\r\n                                        </Node>);\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst getInitialGrid = (state) => {\r\n    // Generate the empty grid\r\n    const grid = [];\r\n    const nodesPerRow = 20;\r\n    const nodesPerCol = 50;\r\n    for (let row = 0; row < nodesPerRow; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < nodesPerCol; col++) {\r\n            currentRow.push(createNode(row, col, \"default\", Infinity));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    // Set the start and finish nodes\r\n    const [startRow, startCol] = state.startNodeCoords;\r\n    const [finishRow, finishCol] = state.finishNodeCoords;\r\n    grid[startRow][startCol] = createNode(startRow, startCol, \"startNode\", 0);\r\n    grid[finishRow][finishCol] = createNode(finishRow, finishCol, \"finishNode\", Infinity);\r\n    return grid;\r\n};\r\n\r\nfunction getWallUpdatedGrid(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        type: node.type === \"wallNode\" ? \"default\" : node.type === \"default\" ? \"wallNode\" : node.type\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\nfunction randomInteger(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}","import React from 'react';\nimport './App.css';\nimport AlgoVisuaizer from './AlgoVisualizer/AlgoVisualizer';\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <AlgoVisuaizer></AlgoVisuaizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}