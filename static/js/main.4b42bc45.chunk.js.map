{"version":3,"sources":["media/tutorial_media/location.png","media/tutorial_media/location_green.png","media/tutorial_media/draw_wall.gif","media/tutorial_media/draw_weight.gif","media/tutorial_media/help_btn.JPG","media/tutorial_media/board_options.JPG","media/tutorial_media/dijkstra.gif","media/tutorial_media/recursive_division.gif","media/tutorial_media/add_checkpoint.gif","media/tutorial_media/drag_nodes.gif","AlgoVisualizer/Node/Node.jsx","AlgoVisualizer/Stats/Stats.jsx","AlgoVisualizer/Legend/Legend.jsx","AlgoVisualizer/TutorialModal/TutorialModal.jsx","Algorithms/helpers.js","Algorithms/Search/dijkstra.js","Algorithms/Search/aStar.js","Algorithms/Search/dfs.js","Algorithms/Search/bfs.js","Algorithms/Generator/recursiveDivision.js","AlgoVisualizer/AlgoVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Node","props","state","this","row","col","type","text","weight","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","typeClass","id","className","Component","Stats","lastAlgoRunString","runTimeSeconds","numNodesInPath","numVisitedNodes","numWalls","numWeights","weightValue","Legend","TutorialModal","pages","page_1","src","location_green","alt","location","page_2","page_3","dijkstra","page_4","page_5","drawWall","page_6","drawWeight","page_7","addCheckpoint","page_8","dragNodes","page_9","recursiveDivision","page_10","boardOptions","page_11","helpBtn","show","pageNum","onBack","onNext","onHide","numPages","Object","keys","length","onClick","animateAlgorithm","algoVisualizer","visitedNodesInOrderList","nodesInShortestPathOrderList","i","Set","size","setTimeout","nodesInShortestPathOrder","delay","node","nodeElement","document","getElementById","replace","setState","running","animateShortestPath","oldClasses","getAllNodes","grid","nodes","push","getUnvisitedNeighbors","neighbors","filter","neighbor","isVisited","getNodesInShortestPathOrder","finishNode","currentNode","unshift","previousNode","clearPath","callback","checkpointNodes","checkpointNodeInfo","distance","Infinity","createNode","isPathDrawn","heuristic","randomInteger","min","max","Math","floor","random","resetGrid","startNodeCoords","finishNodeCoords","getInitialGrid","currentRow","startRow","startCol","finishRow","finishCol","getEuclideanDistance","x1","y1","x2","y2","a","b","sqrt","visualizAlgorithm","computeAlgorithm","startTime","destinationNodeInfo","gridCopy","startNode","originalStartNodeCoords","visitedNodesInOrder","isPathPossible","shortestPath","sort","nodeA","nodeB","getDestinationNodeInfo","coords","Date","getTime","_","cloneDeep","flat","visitedNodesToAnimate","pathNodesToAnimate","computeDijkstra","visitedNodes","unvisitedNodes","closestNode","shift","updateUnvisitedNeighbors","unvisitedNeighbors","computeAStar","abs","getGridWithHeuristics","updateneighbors","getNeighbors","computeDFS","unvisitedNeighbor","newVisitedNodes","computeBFS","queue","path","includes","visualizeRecursiveDivision","generatedWallsInOrder","computeRecursiveDivision","chamber","wallLineRow","wallLineCol","entranceIdx","slice","newTopChamber","newBottomChamber","currentRowTopChamber","currentRowBottomChamber","newLeftChamber","newRightChamber","currentRowLeftChamber","currentRowRightChamber","animateGeneration","setWalls","walls","newNode","AlgoVisualizer","draggingCheckpointNodeInfo","dragging","drawMode","showModal","tutorialPageNum","newGrid","nodeType","getNodeUpdatedGrid","getWallUpdatedGrid","forEach","enteredNodeType","enteredNodeID","randomEmptyNodeCoords","emptyNodes","newRow","nodeRow","getRandomEmptyNodeCoords","getEmptyNodes","startNodeRow","finishNodeRow","checkpointNodeRow","checkpointNode","checkpointNodeCoords","reverse","disabled","addCheckpointNode","toggleNodeDrawType","charAt","toUpperCase","randomizeStartFinishNodes","toggleShowModal","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","App","Boolean","window","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.4b42bc45.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/location.cfc4da78.png\";","module.exports = __webpack_public_path__ + \"static/media/location_green.9675d705.png\";","module.exports = __webpack_public_path__ + \"static/media/draw_wall.fef37b75.gif\";","module.exports = __webpack_public_path__ + \"static/media/draw_weight.e3332e72.gif\";","module.exports = __webpack_public_path__ + \"static/media/help_btn.83bb874c.JPG\";","module.exports = __webpack_public_path__ + \"static/media/board_options.d2ce963a.JPG\";","module.exports = __webpack_public_path__ + \"static/media/dijkstra.0d3d2d40.gif\";","module.exports = __webpack_public_path__ + \"static/media/recursive_division.a36367eb.gif\";","module.exports = __webpack_public_path__ + \"static/media/add_checkpoint.a6fab7e4.gif\";","module.exports = __webpack_public_path__ + \"static/media/drag_nodes.15a8036a.gif\";","import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            type,\r\n            text,\r\n            weight,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave\r\n        } = this.props;\r\n\r\n        const typeClass = type === \"finishNode\"\r\n            ? 'node-finish'\r\n            : type === \"startNode\"\r\n            ? 'node-start'\r\n            : type === \"checkpointNode\"\r\n            ? 'node-checkpoint'\r\n            : type === \"wallNode\"\r\n            ? 'node-wall'\r\n            : type === \"weightNode\"\r\n            ? 'node-weight'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className = {`node ${typeClass}`}\r\n                weight = {weight}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseLeave={() => onMouseLeave(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}><div className='node-center'>{text}</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\n\r\nimport './Stats.css';\r\n\r\nexport default class Stats extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            lastAlgoRunString,\r\n            runTimeSeconds,\r\n            numNodesInPath,\r\n            numVisitedNodes,\r\n            numWalls,\r\n            numWeights,\r\n            weightValue\r\n        } = this.props;\r\n\r\n        return (\r\n            <div id='stats-component' className=\"stats-component\">\r\n                        <p className=\"stat\"><b>Last Algorithm Run: </b> {lastAlgoRunString}</p>\r\n                        <p className=\"stat\"><b>Calculation Time: </b> {runTimeSeconds}ms</p>\r\n                        <p className=\"stat\"><b>Nodes in Path:</b> {numNodesInPath}</p>\r\n                        <p className=\"stat\"><b>Nodes Visited:</b> {numVisitedNodes}</p>\r\n                        <p className=\"stat\"><b>Walls:</b> {numWalls}</p>\r\n                        <p className=\"stat\"><b>Weights:</b> {numWeights}</p>\r\n                        <p className=\"stat\"><b>Weight Value:</b> {weightValue}</p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\nimport './Legend.css';\r\nimport '../Node/Node.css';\r\n\r\nexport default class Legend extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id='legend-component' className=\"legend-component\">\r\n                        <div className='node node-start'></div><p className=\"legend-item\"><b> Start</b></p>\r\n                        <div className='node node-finish'></div><p className=\"legend-item\"><b> Finish</b></p>\r\n                        <div className='node node-wall'></div><p className=\"legend-item\"><b> Wall</b></p>\r\n                        <div className='node node-weight'><div className='node-center'></div></div><p className=\"legend-item\"><b> Weight</b></p>\r\n                        <div className='node node-visited node-legend'></div><p className=\"legend-item\"><b> Visited</b></p>\r\n                        <div className='node node-shortest-path node-legend'></div><p className=\"legend-item\"><b> Path</b></p>\r\n                        <div className='node node-current node-legend'></div><p className=\"legend-item\"><b> Current</b></p>\r\n                        <div className='node node-legend'></div><p className=\"legend-item\"><b> Unvisited</b></p>\r\n                        <div className='node node-checkpoint node-legend'></div><p className=\"legend-item\"><b> Checkpoint</b></p>\r\n                        <div className='node node-checkpoint node-current node-legend'></div><p className=\"legend-item\"><b> Visited Checkpoint</b></p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\nimport './TutorialModal.css';\r\nimport location from '../../media/tutorial_media/location.png';\r\nimport location_green from '../../media/tutorial_media/location_green.png';\r\nimport drawWall from '../../media/tutorial_media/draw_wall.gif';\r\nimport drawWeight from '../../media/tutorial_media/draw_weight.gif';\r\nimport helpBtn from '../../media/tutorial_media/help_btn.JPG';\r\nimport boardOptions from '../../media/tutorial_media/board_options.JPG';\r\nimport dijkstra from '../../media/tutorial_media/dijkstra.gif';\r\nimport recursiveDivision from '../../media/tutorial_media/recursive_division.gif';\r\nimport addCheckpoint from '../../media/tutorial_media/add_checkpoint.gif';\r\nimport dragNodes from '../../media/tutorial_media/drag_nodes.gif';\r\n\r\nexport default class TutorialModal extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n                this.state = {\r\n                    pages: \r\n                        {\r\n                        page_1: \r\n                            <div>\r\n                                <h1>Pathfinding Visualizer Tutorial</h1>\r\n                                <h2>There are many pathfinding algorithms out there to explore.</h2>\r\n                                <p>This application hopes to provides a playground to explore and understand a few of these pathfinding algorithms.</p>\r\n                                <img className=\"location-icon-img\" src={location_green} alt=\"Image of a location icon.\"/>\r\n                                <img className=\"location-icon-img\" src={location} alt=\"Image of a location icon.\"/>\r\n                                <p>For a  brief walkthrough of how to use this application, click the <b><i>Next</i></b> button in the bottom right. To skip the tutorial at any time, click the <b><i>Skip Tutorial</i></b> button in the bottom left. </p>\r\n                            </div>,\r\n                        page_2: \r\n                            <div>\r\n                                <h1>What is pathfinding?</h1>\r\n                                <h2>The objective of pathfinding algorithms is to find a path between two or more points.</h2>\r\n                                <p>Some pathfinding algorithms aim to find the shortest path while others are satisfied with any path. Some pathfinding algorithms called <b><i>weighted</i></b> algorithms take the \"cost\" of moving from one node to another into consideration while <b><i>unweighted</i></b> algorithms do not. There are many pathfinding algorithms out there to explore. This application hopes to provides a playground to explore and understand a few of these pathfinding algorithms.</p>\r\n                            </div>,\r\n                        page_3: \r\n                            <div>\r\n                                <h1>Visualizing Algorithms</h1>\r\n                                <h2>Click the algorithms in the pathfinding section to visualize an algorithm.</h2>\r\n                                <p>In this application, each space(node) in the grid has a cost of 1. The algorithms in the <b><i>weighted</i></b> section consider this cost when pathfinding. Algorithms in the <b><i>unweighted</i></b> section do not.</p>\r\n                                <img className=\"visualize-algorithms-gif\" src={dijkstra} alt=\"Gif of Dijkstra's algorithm running.\"/>\r\n                            </div>,\r\n                        page_4: \r\n                            <div>\r\n                                <h1>Algorithms</h1>\r\n                                <div className=\"algorithm-category\">\r\n                                    <h3>Weighted Algorithms</h3>\r\n                                    <p><b>Dijkstra's Algorithm: </b> This algorithm guarantees the shortest path.</p>\r\n                                    <p><b>A*: </b> A best-first search that makes use of a heuristic to determine the next node to visit. For this application, the heuristic is <b>Manhattan Distance</b>. This algorithm guarantees the shortest path.</p>\r\n                                </div>\r\n                                <div className=\"algorithm-category\">\r\n                                    <h3>Unweighted Algorithms</h3>\r\n                                    <p><b>Depth-First Search (DFS): </b> Bad for pathfinding, depth-first search explores as far as possible on a single path, backtracking when a deadend is reached. This algorithm does <b>not</b> guarantee the shortest path.</p>\r\n                                    <p><b>Breadth-First Search (BFS): </b> Good for pathfinding, breadth-first search explores all of the neighbor nodes, then their neighbors level by level. This algorithm guarantees the shortest path.</p>\r\n                                </div>\r\n                            </div>,\r\n                        page_5: \r\n                            <div>\r\n                                <h1>Drawing Walls</h1>\r\n                                <h2>Click and drag on the grid to draw wall nodes. Clicking or dragging over a wall node will return it to an empty node.</h2>\r\n                                <p>Walls are impenetrable. This means that a path cannot pass through a wall node. </p>\r\n                                <img src={drawWall} alt=\"Gif of drawing walls on the grid.\"/>\r\n                            </div>,\r\n                        page_6: \r\n                            <div>\r\n                                <h1>Drawing Weights</h1>\r\n                                <h2>Click the <b><i>Draw: Wall</i></b> button to toggle between drawing wall and weight nodes. </h2>\r\n                                <p>The current type of node to be drawn is displayed after the \":\". Paths can pass through weight nodes, but at a higher cost. By default, the cost to pass through a weight node is 5 and an empty space is 1. Remember that not all algorithms take weight into account when pathfinding.</p>\r\n                                <img className=\"drawing-weights-gif\" src={drawWeight} alt=\"Gif of drawing weights on the grid.\"/>\r\n                            </div>,\r\n                        page_7: \r\n                            <div>\r\n                                <h1>Adding Checkpoints</h1>\r\n                                <h2>Click the <b><i>Add Checkpoint</i></b> button to add a checkpoint to the grid.</h2>\r\n                                <p>Checkpoints are nodes that must be visited in order before reaching the finish node. If any checkpoint node is unreachable, then there is no path.</p>\r\n                                <img className=\"adding-checkpoints-gif\" src={addCheckpoint} alt=\"Gif of adding checkpoints to the grid.\"/>\r\n                            </div>,\r\n                        page_8: \r\n                            <div>\r\n                                <h1>Dragging Nodes</h1>\r\n                                <h2>The start node, finish node and checkpoint nodes can be dragged to new locations.</h2>\r\n                                <p>Dragging one of the nodes mentioned above over another node above will cause the node to jump to a random open space. Dragging over walls or weights will remove the wall or weight.</p>\r\n                                <img className=\"dragging-nodes-gif\" src={dragNodes} alt=\"Gif of dragging nodes.\"/>\r\n                            </div>,\r\n                        page_9: \r\n                            <div>\r\n                                <h1>Generating mazes</h1>\r\n                                <h2>Click the button in the <b><i>Generators</i></b> section to generate a maze</h2>\r\n                                <img className=\"generators-gif\" src={recursiveDivision} alt=\"Gif of recursive division generating a maze.\"/>\r\n                            </div>,\r\n                        page_10: \r\n                            <div>\r\n                                <h1>Board Options</h1>\r\n                                <h2>Clear the board, clear the path and visited nodes or randomize the start and finish node locations with the buttons in the nav bar.</h2>\r\n                                <img className=\"board-options-img\" src={boardOptions} alt=\"Imgage of board options.\"/>\r\n                            </div>,\r\n                        page_11: \r\n                            <div>\r\n                                <h1>Help</h1>\r\n                                <h2>Click the help button to view this tutorial again.</h2>\r\n                                <img className=\"help-btn-img\" src={helpBtn} alt=\"Image of the help button.\"/>\r\n                            </div>\r\n                        }\r\n                    };\r\n    }\r\n\r\n    render() {\r\n        const { show, pageNum, onBack, onNext, onHide } = this.props;\r\n        const numPages = Object.keys(this.state.pages).length;\r\n\r\n        if(!show) {\r\n            return <div></div>;\r\n        }\r\n\r\n        return (\r\n            <div className=\"tutorial-modal\">\r\n                <p className=\"page-number\">{pageNum}/{Object.keys(this.state.pages).length}</p>\r\n                {this.state.pages[\"page_\" + pageNum]}\r\n                <button className=\"close-btn btn btn-outline-dark\" onClick={() => onHide()}>Skip Tutorial</button>\r\n                <div className=\"navigation-btn-container\">\r\n                    <button className={pageNum === 1 ? \"hidden\" : \"back-btn btn btn-outline-dark\" } onClick={() => onBack()}>Back</button>\r\n                    <button className={\"next-btn btn btn-outline-dark\"} onClick={() => pageNum === numPages ? onHide() : onNext() }>{pageNum === numPages ? \"Finish\" : \"Next\"}</button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import _ from \"lodash\";\r\n\r\nexport function animateAlgorithm(algoVisualizer, visitedNodesInOrderList, nodesInShortestPathOrderList) {\r\n    const delay = 10;\r\n    const shortestPathDelay = 25;\r\n    var numVisitedNodes = 0;\r\n    var numNodesInPath = 0;\r\n\r\n    numVisitedNodes += visitedNodesInOrderList.length;\r\n    for (let i = 0; i < visitedNodesInOrderList.length; i++) {\r\n        if (i === visitedNodesInOrderList.length - 1) {\r\n            numNodesInPath += new Set(nodesInShortestPathOrderList).size;\r\n            // Animate the shortest path\r\n            setTimeout(() => {\r\n                animateShortestPath(algoVisualizer, nodesInShortestPathOrderList, shortestPathDelay);\r\n            }, delay * i);\r\n        }\r\n        \r\n        setTimeout(() => {\r\n            const node = visitedNodesInOrderList[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the visted nodes\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-visited';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    algoVisualizer.setState({ numVisitedNodes, numNodesInPath });\r\n}\r\n\r\nfunction animateShortestPath(algoVisualizer, nodesInShortestPathOrder, delay=25) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            // Redraw element to restart animation on nodes with class node-shortest-path\r\n            var nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n            nodeElement.className = nodeElement.className.replace(\" node-shortest-path\", \"\");\r\n            setTimeout(()=>{nodeElement.className = nodeElement.className + ' node-shortest-path';}, 10);\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{algoVisualizer.setState({running: false});}, delay * nodesInShortestPathOrder.length);\r\n}\r\n\r\nexport function animateGeneration(algoVisualizer, generatedWallsInOrder, callback=null) {\r\n    const { grid } = algoVisualizer.state;\r\n    const delay = 10;\r\n    for (let i = 0; i < generatedWallsInOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = generatedWallsInOrder[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the walls\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-wall';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{\r\n        algoVisualizer.setState({running: false});\r\n        if(callback) callback(algoVisualizer, grid, generatedWallsInOrder);\r\n    }, delay * generatedWallsInOrder.length);\r\n}\r\n\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    var currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function sortNodesByDistance(nodes) {\r\n    nodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function sortNodesByDistanceAndHeuristic(nodes){\r\n    nodes.sort(function (nodeA, nodeB) {\r\n        // Sort on distance\r\n        if(nodeA.distance > nodeB.distance) {\r\n            return 1;\r\n        } else if (nodeA.distance < nodeB.distance) {\r\n            return -1;\r\n        } else {\r\n            // If the distances are the same,\r\n            // sort on distance - heuristic\r\n            if(nodeA.heuristic > nodeB.heuristic) {\r\n                return 1;\r\n            } else if (nodeA.heuristic < nodeB.heuristic) {\r\n                return -1;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function clearPath(algoVisualizer, callback=null) {\r\n    var { grid, checkpointNodes } = algoVisualizer.state;\r\n\r\n    // Mark checkpoint nodes as unvisited \r\n    for(let checkpointNodeInfo of checkpointNodes){\r\n        checkpointNodeInfo.isVisited = false;\r\n    }\r\n    \r\n    for(const row of grid) {\r\n        for(var node of row){\r\n            // update node values\r\n            var distance = node.type === \"startNode\" ? 0 : Infinity; \r\n            grid[node.row][node.col] = createNode(node.row, node.col, node.type, distance, node.text, node.weight);\r\n            // update css class\r\n            if(node.type === \"default\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n            } else if(node.type === \"checkpointNode\") {\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-checkpoint';\r\n            } else if(node.type === \"weightNode\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-weight';\r\n            }\r\n        }\r\n    }\r\n    algoVisualizer.setState({ grid, checkpointNodes, isPathDrawn: false, numNodesInPath: 0, numVisitedNodes: 0 }, callback);\r\n}\r\n\r\nexport function createNode(row, col, type, distance, text=\"\", weight=1) {\r\n    return {\r\n        row,\r\n        col,\r\n        type,\r\n        text,\r\n        distance,\r\n        weight,\r\n        heuristic: 0,\r\n        isVisited: false,\r\n        previousNode: null\r\n    }\r\n}\r\n\r\nexport function randomInteger(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function randomEvenInteger(min, max) {\r\n    var temp =(Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2;\r\n    return temp;\r\n}\r\n\r\nexport function randomOddInteger(min, max) {\r\n    var temp = (Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2 + 1;\r\n    return temp;\r\n}\r\n\r\nexport function resetGrid(algoVisualizer, callback) {\r\n    var { grid, startNodeCoords, finishNodeCoords } = algoVisualizer.state;\r\n\r\n    // reset node classnames\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n        }\r\n    }\r\n\r\n    // set start and finish node classnames\r\n    document.getElementById(`node-${startNodeCoords[0]}-${startNodeCoords[1]}`).className = 'node node-start';\r\n    document.getElementById(`node-${finishNodeCoords[0]}-${finishNodeCoords[1]}`).className = 'node node-finish';\r\n    grid = getInitialGrid(algoVisualizer);\r\n    algoVisualizer.setState({ grid, numWeights: 0, numWalls: 0, numNodesInPath: 0, numVisitedNodes: 0, checkpointNodes: [] }, callback);\r\n}\r\n\r\nexport function getInitialGrid(algoVisualizer){\r\n    // Generate the empty grid\r\n    const grid = [];\r\n    const nodesPerRow = 20;\r\n    const nodesPerCol = 50;\r\n    for (let row = 0; row < nodesPerRow; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < nodesPerCol; col++) {\r\n            currentRow.push(createNode(row, col, \"default\", Infinity));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    // Set the start and finish nodes\r\n    const [startRow, startCol] = algoVisualizer.state.startNodeCoords;\r\n    const [finishRow, finishCol] = algoVisualizer.state.finishNodeCoords;\r\n    grid[startRow][startCol] = createNode(startRow, startCol, \"startNode\", 0);\r\n    grid[finishRow][finishCol] = createNode(finishRow, finishCol, \"finishNode\", Infinity);\r\n    return grid;\r\n};\r\n\r\nexport function getEuclideanDistance(x1, y1, x2, y2){\r\n    var a = x1 - x2;\r\n    var b = y1 - y2;\r\n    return Math.sqrt( a*a + b*b );\r\n}\r\n\r\nexport function getRandomEmptyNodeCoords(algoVisualizer){\r\n    var { grid } = algoVisualizer.state;\r\n    var emptyNodes = [];\r\n    // Get all empty nodes\r\n    for(var row of grid){\r\n        var newRow = row.filter(node => node.type === \"default\");\r\n        if(newRow.length > 0) emptyNodes.push(newRow);\r\n    }\r\n\r\n    if(emptyNodes.length > 0) {\r\n        var nodeRow = randomInteger(0, emptyNodes.length - 1);\r\n        var node = emptyNodes[nodeRow][randomInteger(0, emptyNodes[nodeRow].length - 1)];\r\n        return [node.row, node.col];\r\n    }\r\n}\r\n\r\nexport function visualizAlgorithm(computeAlgorithm, lastAlgoRunString, algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    var startTime, runTimeSeconds, destinationNodeInfo, gridCopy, startNode, finishNode;\r\n    var originalStartNodeCoords = algoVisualizer.state.startNodeCoords;\r\n    var visitedNodesInOrder = [];\r\n    var nodesInShortestPathOrder = [];\r\n    var checkpointNodes = algoVisualizer.state.checkpointNodes;\r\n    var isPathPossible = true;\r\n    var shortestPath = [];\r\n    checkpointNodes.sort((nodeA, nodeB) => nodeA.id - nodeB.id);\r\n\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    // Reset the checkpoint nodes\r\n    for(var checkpointNodeInfo of checkpointNodes) {\r\n        checkpointNodeInfo.isVisited = false;\r\n        checkpointNodeInfo.distance = Infinity;\r\n    }\r\n\r\n    while(algoVisualizer.getDestinationNodeInfo().coords !== finishNodeCoords) {\r\n        destinationNodeInfo = algoVisualizer.getDestinationNodeInfo();\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        gridCopy[startNodeCoords[0]][startNodeCoords[1]].distance = 0;\r\n        if(lastAlgoRunString === \"DFS\") {\r\n            startNode = gridCopy[startNodeCoords[0]][startNodeCoords[1]];\r\n            finishNode = gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]];\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNode, finishNode, [])[1]);\r\n        } else {\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNodeCoords, destinationNodeInfo.coords));\r\n        }\r\n        shortestPath = getNodesInShortestPathOrder(gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]])\r\n        nodesInShortestPathOrder.push(shortestPath);\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        startNodeCoords = destinationNodeInfo.coords;\r\n        destinationNodeInfo.isVisited = true;\r\n        for(let checkpointNodeInfo of checkpointNodes) {\r\n            if(checkpointNodeInfo.id === destinationNodeInfo.id - 1) checkpointNodeInfo = destinationNodeInfo;\r\n        }\r\n\r\n        if(shortestPath.length <= 1) {\r\n            isPathPossible = false;\r\n            break;\r\n        }\r\n    }\r\n    \r\n    if(isPathPossible) {\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        gridCopy[startNodeCoords[0]][startNodeCoords[1]].distance = 0;\r\n        if(lastAlgoRunString === \"DFS\") {\r\n            startNode = gridCopy[startNodeCoords[0]][startNodeCoords[1]];\r\n            finishNode = gridCopy[finishNodeCoords[0]][finishNodeCoords[1]];\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNode, finishNode, [])[1]);\r\n        } else {\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNodeCoords, finishNodeCoords));\r\n        }\r\n        nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[finishNodeCoords[0]][finishNodeCoords[1]]));\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        animateAlgorithm(algoVisualizer, visitedNodesInOrder.flat(), nodesInShortestPathOrder.flat());\r\n    } else {\r\n        animateAlgorithm(algoVisualizer, visitedNodesInOrder.flat(), []);\r\n    }\r\n\r\n    algoVisualizer.setState({ visitedNodesToAnimate: visitedNodesInOrder, pathNodesToAnimate: nodesInShortestPathOrder, checkpointNodes, isPathDrawn: true, runTimeSeconds, lastAlgoRunString});\r\n}","import { animateAlgorithm, sortNodesByDistance, getAllNodes, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeDijkstra(grid, startNodeCoords, finishNodeCoords) {\r\n  const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n  const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n  startNode.distance = 0;\r\n  var visitedNodes = [];\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while(unvisitedNodes.length){\r\n      // Sort the nodes by distance\r\n      sortNodesByDistance(unvisitedNodes);\r\n      // Get the closest unvisited node\r\n      var closestNode = unvisitedNodes.shift();\r\n      // unvisitedNodes.unshift();\r\n      // Skip if the closest node is a wall\r\n      if(closestNode.type === \"wallNode\") continue;\r\n      // Return if there are no possible routes\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n\r\n      // Check if the current node is the finish node\r\n      if(closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + neighbor.weight;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nexport function visualizeDijkstra(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n  algoVisualizer.setState({running: true});\r\n  clearPath(algoVisualizer);\r\n  var startTime = new Date().getTime();\r\n  const visitedNodesInOrder = computeDijkstra(grid, startNodeCoords, finishNodeCoords);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  var runTimeSeconds = new Date().getTime() - startTime;\r\n  animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n  algoVisualizer.setState({ isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"Dijkstra\" });\r\n}\r\n\r\n\r\n","import { animateAlgorithm, sortNodesByDistanceAndHeuristic, getAllNodes, getNeighbors, getNodesInShortestPathOrder, clearPath, getEuclideanDistance } from '../helpers.js';\r\nimport _ from \"lodash\";\r\n\r\nexport function computeAStar(grid, startNodeCoords, finishNodeCoords) {\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    grid = getGridWithHeuristics(grid, finishNode, \"manhattan\");\r\n    startNode.distance = 0;\r\n    var visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(unvisitedNodes.length){\r\n        // Sort the nodes by distance\r\n        sortNodesByDistanceAndHeuristic(unvisitedNodes);\r\n        // Get the closest unvisited node\r\n        var closestNode = unvisitedNodes.shift();\r\n        // Skip if the closest node is a wall\r\n        if(closestNode.type === \"wallNode\") continue;\r\n        // Return if there are no possible routes\r\n        if (closestNode.distance === Infinity) return visitedNodes;\r\n        closestNode.isVisited = true;\r\n        visitedNodes.push(closestNode);\r\n\r\n        // Check if the current node is the finish node\r\n        if(closestNode === finishNode) return visitedNodes;\r\n        updateneighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nexport function visualizeAStar(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    var startTime, runTimeSeconds, destinationNodeInfo, gridCopy;\r\n    var { originalStartNodeCoords, checkpointNodes } = algoVisualizer.state;\r\n    var visitedNodesInOrder = [];\r\n    var nodesInShortestPathOrder = [];\r\n\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n\r\n    while(algoVisualizer.getDestinationNodeInfo().coords !== finishNodeCoords) {\r\n        destinationNodeInfo = algoVisualizer.getDestinationNodeInfo();\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        visitedNodesInOrder.push(computeAStar(gridCopy, startNodeCoords, destinationNodeInfo.coords));\r\n        nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]]));\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        startNodeCoords = destinationNodeInfo.coords;\r\n        destinationNodeInfo.isVisited = true;\r\n        checkpointNodes[destinationNodeInfo.id - 1] = destinationNodeInfo;\r\n    }\r\n    \r\n    startTime = new Date().getTime();\r\n    gridCopy = _.cloneDeep(grid);\r\n    visitedNodesInOrder.push(computeAStar(gridCopy, startNodeCoords, finishNodeCoords));\r\n    nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[finishNodeCoords[0]][finishNodeCoords[1]]));\r\n    runTimeSeconds = new Date().getTime() - startTime;\r\n\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({visitedNodesToAnimate: visitedNodesInOrder, pathNodesToAnimate: nodesInShortestPathOrder, checkpointNodes, isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"A*\"});\r\n}\r\n\r\nfunction updateneighbors(node, grid) {\r\n    const neighbors = getNeighbors(node, grid);\r\n    for (const neighbor of neighbors) {\r\n        if(neighbor.isVisited){\r\n            if(neighbor.distance - neighbor.heuristic < node.previousNode.distance - node.previousNode.heuristic){\r\n                node.previousNode = neighbor;\r\n            }\r\n        } else {\r\n            if(node.distance === 0){\r\n                neighbor.distance = neighbor.weight + neighbor.heuristic; \r\n            } else {\r\n                neighbor.distance = node.distance - node.heuristic + neighbor.weight + neighbor.heuristic;\r\n            }\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getGridWithHeuristics(grid, finishNode, heuristic=\"manhattan\"){\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            if(heuristic === \"manhattan\"){\r\n                // Manhattan distance heuristic\r\n                node.heuristic = Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col);\r\n            } else if(heuristic === \"euclidean\") {\r\n                // Euclidean distance \r\n                node.heuristic = getEuclideanDistance(node.row, node.col, finishNode.row, finishNode.col);\r\n            }\r\n        }\r\n    }\r\n    return grid;\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeDFS(grid, currentNode, finishNode, visitedNodes) {\r\n    visitedNodes.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) return [visitedNodes, visitedNodes];\r\n    for(let unvisitedNeighbor of getUnvisitedNeighbors(currentNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")) {\r\n        if(!unvisitedNeighbor.isVisited){\r\n            unvisitedNeighbor.previousNode = currentNode;\r\n            var newVisitedNodes = computeDFS(grid, unvisitedNeighbor, finishNode, visitedNodes)[0];\r\n            if(newVisitedNodes) return [newVisitedNodes, newVisitedNodes];\r\n        }\r\n    }\r\n    return [null, visitedNodes];\r\n}\r\n\r\nexport function visualizeDFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeDFS(grid, startNode, finishNode, [])[1];\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    if(visitedNodesInOrder) animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder); else algoVisualizer.setState({running: false});\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"DFS\"});\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeBFS(grid, startNodeCoords, finishNodeCoords) {\r\n    var startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    var finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var queue = [startNode];\r\n    var path = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    if(startNode === finishNode) return path;\r\n\r\n    while(queue){\r\n        startNode = queue.shift();\r\n\r\n        if(startNode){\r\n            for(var neighbor of getUnvisitedNeighbors(startNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")){\r\n                if(!path.includes(neighbor)){\r\n                    neighbor.previousNode = startNode;\r\n                    neighbor.isVisited = true;\r\n                    path.push(neighbor);\r\n                    queue.push(neighbor);\r\n    \r\n                    if(neighbor === finishNode) return path;\r\n                }\r\n            }\r\n        } else {\r\n            return path;\r\n        }\r\n\r\n    }\r\n    return path;\r\n}\r\n\r\nexport function visualizeBFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeBFS(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"BFS\"});\r\n}","import {resetGrid, randomInteger, animateGeneration} from '../helpers';\r\n\r\nexport function computeRecursiveDivision(chamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder){\r\n    \r\n    const min_chamber_size = 2;\r\n    var wallLineRow, wallLineCol, entranceIdx;\r\n\r\n    // If minimum chamber size is reached, return the generated walls\r\n    if(chamber.length <= min_chamber_size && chamber[0].length <= min_chamber_size ){\r\n        return generatedWallsInOrder;\r\n    }\r\n\r\n    // Create the outer walls\r\n    if(generatedWallsInOrder.length === 0) {\r\n        for(let row = 0; row < chamber.length; row++){\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(row === 0 || col === 0 || row === chamber.length - 1 || col === chamber[0].length - 1 ){\r\n                    if(chamber[row][col].type !== \"startNode\" && chamber[row][col].type !== \"finishNode\") generatedWallsInOrder.push(chamber[row][col]);\r\n                }\r\n            }\r\n        }\r\n        chamber = chamber.slice(1, chamber.length - 1);\r\n        for(let row = 0; row < chamber.length; row++){\r\n            chamber[row] = chamber[row].slice(1, chamber[row].length - 1);\r\n        }\r\n    }\r\n\r\n    // Divide chamber horizonally if the chamber is more tall than wide\r\n    if(chamber.length > chamber[0].length){\r\n        // Select a random row within the chamber to draw walls. \r\n        // Leave a one row space to prevent a double wall\r\n        wallLineRow = randomInteger(1, chamber.length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber[0].length - 1;\r\n        // Add walls along that row\r\n        for(var col = 0; col < chamber[wallLineRow].length; col++){\r\n            if(col !== entranceIdx && chamber[wallLineRow][col] && chamber[wallLineRow][col].type !== \"startNode\" && chamber[wallLineRow][col].type !== \"finishNode\") generatedWallsInOrder.push(chamber[wallLineRow][col]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newTopChamber = [];\r\n        var newBottomChamber = [];\r\n        for(let row = 0; row < chamber.length; row++){\r\n            const currentRowTopChamber = [];\r\n            const currentRowBottomChamber = [];\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(row < wallLineRow) currentRowTopChamber.push(chamber[row][col]);\r\n                if(row > wallLineRow) currentRowBottomChamber.push(chamber[row][col]); \r\n            }\r\n            if(currentRowTopChamber.length !== 0) newTopChamber.push(currentRowTopChamber);\r\n            if(currentRowBottomChamber.length !== 0) newBottomChamber.push(currentRowBottomChamber);\r\n            \r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newTopChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newBottomChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n\r\n    } else {\r\n        // Select a random col within the chamber to draw walls. \r\n        // Leave a one col space to prevent a double wall\r\n        wallLineCol = randomInteger(1, chamber[0].length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber.length - 1;\r\n        // Add walls along that col\r\n        for(let row = 0; row < chamber.length; row++){\r\n            if(row !== entranceIdx && chamber[row][wallLineCol] && chamber[row][wallLineCol].type !== \"startNode\" && chamber[row][wallLineCol].type !== \"finishNode\") generatedWallsInOrder.push(chamber[row][wallLineCol]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newLeftChamber = [];\r\n        var newRightChamber = [];\r\n        for(let row = 0; row < chamber.length; row++){\r\n            const currentRowLeftChamber = [];\r\n            const currentRowRightChamber = [];\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(col < wallLineCol) currentRowLeftChamber.push(chamber[row][col]);\r\n                if(col > wallLineCol) currentRowRightChamber.push(chamber[row][col]);\r\n            }\r\n            newLeftChamber.push(currentRowLeftChamber);\r\n            newRightChamber.push(currentRowRightChamber);\r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newLeftChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newRightChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n    }\r\n\r\n    return generatedWallsInOrder;\r\n}\r\n\r\nexport function visualizeRecursiveDivision(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    resetGrid(algoVisualizer, ()=>{\r\n        var startTime = new Date().getTime();\r\n        // Get the generated walls in order\r\n        const generatedWallsInOrder = computeRecursiveDivision(grid, startNodeCoords, finishNodeCoords, []);\r\n        var runTimeSeconds = new Date().getTime() - startTime;\r\n        algoVisualizer.setState({ runTimeSeconds, lastAlgoRunString: \"Recursive Division\" });\r\n        animateGeneration(algoVisualizer, generatedWallsInOrder, setWalls);\r\n    });\r\n}\r\n\r\nfunction setWalls(algoVisualizer, grid, walls){\r\n    for(var node of walls){\r\n        const newNode = {\r\n            ...node,\r\n            type: \"wallNode\"\r\n            };\r\n        grid[node.row][node.col] = newNode;\r\n    }\r\n    algoVisualizer.setState({ grid, numWalls: walls.length });\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport Stats from './Stats/Stats';\r\nimport Legend from './Legend/Legend';\r\nimport TutorialModal from './TutorialModal/TutorialModal';\r\n\r\nimport {computeDijkstra} from '../Algorithms/Search/dijkstra';\r\nimport {computeAStar} from '../Algorithms/Search/aStar';\r\nimport {computeDFS} from '../Algorithms/Search/dfs';\r\nimport {computeBFS} from '../Algorithms/Search/bfs';\r\nimport {getInitialGrid, resetGrid, clearPath, createNode, randomInteger, getRandomEmptyNodeCoords, visualizAlgorithm} from '../Algorithms/helpers';\r\nimport './AlgoVisualizer.css';  \r\nimport { visualizeRecursiveDivision } from '../Algorithms/Generator/recursiveDivision';\r\n\r\nexport default class AlgoVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            startNodeCoords: [5, 10],\r\n            finishNodeCoords: [7, 40],\r\n            checkpointNodes: [],\r\n            draggingCheckpointNodeInfo: {},\r\n            running: false,\r\n            dragging: \"\",\r\n            isPathDrawn: false,\r\n            lastAlgoRunString: \"\",\r\n            runTimeSeconds: 0,\r\n            numNodesInPath: 0,\r\n            numVisitedNodes: 0,\r\n            numWalls: 0,\r\n            numWeights: 0,\r\n            weight: 5,\r\n            drawMode: \"wall\",\r\n            showModal: true,\r\n            tutorialPageNum: 1\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = getInitialGrid(this);\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        var type = this.state.grid[row][col].type;\r\n        var { drawMode, running, grid, numWalls, numWeights, weight, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n        var newGrid;\r\n        var nodeType = \"default\";\r\n\r\n        if(running) return; \r\n\r\n        if([\"wallNode\", \"weightNode\", \"default\"].includes(type)) {\r\n            if(type === \"wallNode\") numWalls -= 1;\r\n            if(type === \"weightNode\") numWeights -= 1;\r\n\r\n            if(drawMode === \"weight\") {\r\n                if([\"default\", \"wallNode\"].includes(type)) {\r\n                    numWeights += 1;\r\n                    nodeType = \"weightNode\";\r\n                }\r\n                newGrid = getNodeUpdatedGrid(grid, row, col, nodeType, \"\", weight);\r\n            }\r\n            if(drawMode === \"wall\") {\r\n                if([\"default\", \"weightNode\"].includes(type)) numWalls += 1;\r\n                newGrid = getWallUpdatedGrid(grid, row, col);\r\n            }\r\n            this.setState({ grid: newGrid, dragging: type, numWalls, numWeights });\r\n        } else if (type === \"checkpointNode\") {\r\n            // Keep track of which checkpoiontNode is being dragged\r\n            checkpointNodes.forEach(checkpointNodeInfo => {\r\n                if (checkpointNodeInfo.coords[0] === row && checkpointNodeInfo.coords[1] === col) {\r\n                    draggingCheckpointNodeInfo = checkpointNodeInfo;\r\n                }\r\n            });\r\n            this.setState({ dragging: type, draggingCheckpointNodeInfo });\r\n        } else {\r\n            this.setState({ dragging: type });\r\n        }\r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        var { grid, running, dragging, drawMode, weight, numWalls, numWeights, startNodeCoords, finishNodeCoords, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n        const enteredNodeType = grid[row][col].type;\r\n        var enteredNodeID = \"\";\r\n        var newGrid = grid;\r\n        var nodeType = \"\";\r\n\r\n        if(running || dragging === \"\") return;\r\n\r\n        if([\"startNode\", \"finishNode\", \"checkpointNode\"].includes(dragging)) {\r\n            newGrid = dragging === \"checkpointNode\" \r\n                ? getNodeUpdatedGrid(newGrid, row, col, dragging, draggingCheckpointNodeInfo.id)\r\n                : getNodeUpdatedGrid(newGrid, row, col, dragging);\r\n\r\n            if(enteredNodeType === \"wallNode\") {\r\n                numWalls -= 1;\r\n            } else {\r\n                const randomEmptyNodeCoords = getRandomEmptyNodeCoords(this);\r\n                if(enteredNodeType === \"finishNode\") {\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"finishNode\");\r\n                    finishNodeCoords = randomEmptyNodeCoords;\r\n                } else if(enteredNodeType === \"startNode\") {\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"startNode\");\r\n                    startNodeCoords = randomEmptyNodeCoords;\r\n                } else if(enteredNodeType === \"checkpointNode\") {\r\n                    // Update checkpointNode state\r\n                    checkpointNodes.forEach(checkpointNodeInfo => {\r\n                        if(checkpointNodeInfo.coords[0] === row && checkpointNodeInfo.coords[1] === col) {\r\n                            checkpointNodeInfo.coords = randomEmptyNodeCoords;\r\n                            enteredNodeID = checkpointNodeInfo.id;\r\n                        }\r\n                    });\r\n                    draggingCheckpointNodeInfo.coords = [row, col];\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"checkpointNode\", enteredNodeID);\r\n                }\r\n            }\r\n        } else {\r\n            if(drawMode === \"wall\") {\r\n                numWalls = enteredNodeType === \"wallNode\" ? numWalls - 1 : numWalls + 1;\r\n                newGrid = getWallUpdatedGrid(newGrid, row, col);\r\n            }else if(drawMode === \"weight\") {\r\n                if(enteredNodeType === \"weightNode\") {\r\n                    numWeights -= 1;\r\n                    nodeType = \"default\";\r\n                    weight = 1;\r\n                } else {\r\n                    if(enteredNodeType === \"wallNode\") numWalls -= 1;\r\n                    numWeights += 1;\r\n                    nodeType = \"weightNode\";\r\n                }\r\n                newGrid = getNodeUpdatedGrid(newGrid, row, col, nodeType, \"\", weight);\r\n            }\r\n        }\r\n        this.setState({ grid: newGrid, numWalls, numWeights, startNodeCoords, finishNodeCoords, checkpointNodes, draggingCheckpointNodeInfo });\r\n    }\r\n    \r\n    handleMouseLeave(row, col){\r\n        if(this.state.running) return;\r\n        if([\"startNode\", \"finishNode\", \"checkpointNode\"].includes(this.state.dragging)){\r\n            if(this.state.isPathDrawn) clearPath(this);\r\n            this.setState({ grid: getNodeUpdatedGrid(this.state.grid, row, col, \"default\") });\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        var { running, grid, dragging, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n        if(running) return;\r\n        if(dragging === \"startNode\"){\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"startNode\");\r\n            this.setState({ grid: newGrid, dragging: \"\", startNodeCoords: [row, col] });\r\n        } else if(dragging === \"finishNode\") {\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"finishNode\");\r\n            this.setState({ grid: newGrid, dragging: \"\", finishNodeCoords: [row, col] });\r\n        } else if(dragging === \"checkpointNode\") {\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"checkpointNode\", draggingCheckpointNodeInfo.id);\r\n            checkpointNodes.forEach(checkpointNodeInfo => {\r\n                if(checkpointNodeInfo.id === draggingCheckpointNodeInfo.id) checkpointNodeInfo.coords = [row, col];\r\n            });\r\n            this.setState({ grid: newGrid, dragging: \"\", checkpointNodes });\r\n        }\r\n        this.setState({ dragging: \"\" });\r\n    }\r\n  \r\n    getEmptyNodes(grid) {\r\n        var emptyNodes = [];\r\n        // Get all empty nodes\r\n        for(var row of grid){\r\n            var newRow = row.filter(node => node.type === \"default\");\r\n            if(newRow.length > 0) emptyNodes.push(newRow);\r\n        }\r\n        return emptyNodes;\r\n    }\r\n\r\n    randomizeStartFinishNodes() {\r\n        var {grid, startNodeCoords, finishNodeCoords } = this.state;\r\n        \r\n        grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"default\", Infinity);\r\n        grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"default\", Infinity);\r\n        \r\n        // Get all empty nodes\r\n        var emptyNodes = this.getEmptyNodes(grid);\r\n\r\n        if(emptyNodes.length > 0) {\r\n            var startNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var startNode = emptyNodes[startNodeRow][randomInteger(0, emptyNodes[startNodeRow].length - 1)];\r\n            var finishNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var finishNode = emptyNodes[finishNodeRow][randomInteger(0, emptyNodes[finishNodeRow].length - 1)];\r\n    \r\n            startNodeCoords = [startNode.row, startNode.col];\r\n            finishNodeCoords = [finishNode.row, finishNode.col];\r\n            \r\n            grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"startNode\", 0);\r\n            grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"finishNode\", Infinity);\r\n            \r\n            this.setState({ grid, startNodeCoords, finishNodeCoords });\r\n        }\r\n    }\r\n\r\n    addCheckpointNode(){\r\n        var { grid, checkpointNodes, isPathDrawn } = this.state;\r\n\r\n        // If there is a path, clear it and mark checkpoints as unvisited \r\n        if(isPathDrawn) clearPath(this);\r\n        \r\n        // Get all empty nodes\r\n        var emptyNodes = this.getEmptyNodes(grid);\r\n\r\n        // If there is empty space, add a checkpoint node\r\n        if(emptyNodes.length > 0) {\r\n            var checkpointNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var checkpointNode = emptyNodes[checkpointNodeRow][randomInteger(0, emptyNodes[checkpointNodeRow].length - 1)];\r\n            var checkpointNodeCoords = [checkpointNode.row, checkpointNode.col];\r\n            var checkpointNodeInfo = {\r\n                id:checkpointNodes.length + 1,\r\n                coords:checkpointNodeCoords,\r\n                isVisited:false\r\n            };\r\n    \r\n            grid[checkpointNodeCoords[0]][checkpointNodeCoords[1]] = createNode(checkpointNodeCoords[0], checkpointNodeCoords[1], \"checkpointNode\", Infinity, checkpointNodeInfo.id);\r\n            \r\n            checkpointNodes.push(checkpointNodeInfo);\r\n            // Update the state\r\n            this.setState({ grid, checkpointNodes });\r\n        }\r\n    }\r\n\r\n    toggleNodeDrawType(){\r\n        this.setState({ drawMode: this.state.drawMode === \"wall\" ? \"weight\" : \"wall\" });\r\n    }\r\n\r\n    getDestinationNodeInfo() {\r\n        var { checkpointNodes, finishNodeCoords } = this.state;\r\n        for(var checkpointNodeInfo of checkpointNodes.reverse()) {\r\n            if(!checkpointNodeInfo.isVisited) return checkpointNodeInfo;\r\n        }\r\n\r\n        return {id:0, coords:finishNodeCoords, isVisited: false};\r\n    }\r\n\r\n    toggleShowModal() {\r\n        this.setState({tutorialPageNum: 1, showModal: !this.state.showModal});\r\n    }\r\n\r\n    render() {\r\n        const {grid, startNodeCoords, finishNodeCoords, runTimeSeconds, numNodesInPath, numVisitedNodes, numWalls, numWeights, weight, lastAlgoRunString} = this.state;\r\n\r\n        return (\r\n            <div className='body'>\r\n                <div className='menu'>\r\n                    <h1 className='title'>Pathfinding Visualizer</h1>\r\n                    <div className='menu-group-container'>\r\n                        <div className='menu-group'>\r\n                            <h2>Pathfinding</h2>\r\n                            <div className='menu-subgroup'>\r\n                                <h3>Weighted</h3>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeDijkstra, \"Dijkstra\", this, grid, startNodeCoords, finishNodeCoords)}>Dijkstra</button>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeAStar, \"A*\", this, grid, startNodeCoords, finishNodeCoords)}>A*</button>\r\n                            </div>\r\n                            <div className='menu-subgroup'>\r\n                                <h3>Unweighted</h3>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeDFS, \"DFS\", this, grid, startNodeCoords, finishNodeCoords)}>DFS</button>\r\n                                <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeBFS, \"BFS\", this, grid, startNodeCoords, finishNodeCoords)}>BFS</button>\r\n                            </div>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Generators</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeRecursiveDivision(this, grid, startNodeCoords, finishNodeCoords)}>Recursive Division</button>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Board Options</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> this.addCheckpointNode()}>Add Checkpoint</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> this.toggleNodeDrawType()}>Draw: {this.state.drawMode.charAt(0).toUpperCase() + this.state.drawMode.slice(1)}</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> resetGrid(this)}>Clear Board</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this)}>Clear Path</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this, this.randomizeStartFinishNodes)}>Randomize Start and End Nodes</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"grid-container\">\r\n                    <button className=\"btn help-btn\" onClick={()=> this.toggleShowModal()}><p className='help-txt'>?</p></button>\r\n                    <Legend></Legend>\r\n                    <Stats\r\n                        runTimeSeconds={runTimeSeconds}\r\n                        numNodesInPath={numNodesInPath}\r\n                        numVisitedNodes={numVisitedNodes}\r\n                        numWalls={numWalls}\r\n                        numWeights={numWeights}\r\n                        weightValue={weight}\r\n                        lastAlgoRunString={lastAlgoRunString}\r\n                        ></Stats>\r\n                    <div className=\"grid\">\r\n                        {grid.map((row, rowIdx) => {\r\n                            return (\r\n                                <div key={rowIdx}>\r\n                                    {row.map((node, nodeIdx) => {\r\n                                        const { row, col, type, distance, text, weight } = node;\r\n                                        return (\r\n                                            <Node\r\n                                                key={nodeIdx}\r\n                                                className='node'\r\n                                                row={row}\r\n                                                col={col}\r\n                                                type={type}\r\n                                                text={text}\r\n                                                weight={weight}\r\n                                                distance={distance}\r\n                                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                                onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                                                onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\r\n                                            ></Node>);\r\n                                    })}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                </div>\r\n\r\n                <TutorialModal\r\n                    show={this.state.showModal}\r\n                    pageNum={this.state.tutorialPageNum}\r\n                    onHide={() => this.toggleShowModal()}\r\n                    onNext={() => this.setState({tutorialPageNum: this.state.tutorialPageNum + 1})}\r\n                    onBack={() => this.setState({tutorialPageNum: this.state.tutorialPageNum > 0 ? this.state.tutorialPageNum - 1 : 0})}\r\n                />\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction getWallUpdatedGrid(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        type: node.type === \"wallNode\" ? \"default\" : node.type === \"default\" || node.type === \"weightNode\" ? \"wallNode\" : node.type\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\nfunction getNodeUpdatedGrid(grid, row, col, type, text=\"\", weight=1) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    var newNode = {\r\n        ...node,\r\n        weight,\r\n        text,\r\n        type\r\n    };\r\n\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport AlgoVisuaizer from './AlgoVisualizer/AlgoVisualizer';\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <AlgoVisuaizer></AlgoVisuaizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}