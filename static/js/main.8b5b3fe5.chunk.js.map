{"version":3,"sources":["AlgoVisualizer/Node/Node.jsx","AlgoVisualizer/Stats/Stats.jsx","AlgoVisualizer/Legend/Legend.jsx","Algorithms/helpers.js","Algorithms/Search/dijkstra.js","Algorithms/Search/aStar.js","Algorithms/Search/dfs.js","Algorithms/Search/bfs.js","Algorithms/Generator/recursiveDivision.js","AlgoVisualizer/AlgoVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","row","col","type","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","typeClass","id","className","Component","Stats","lastAlgoRunString","runTimeSeconds","numNodesInPath","numVisitedNodes","numWalls","Legend","animateAlgorithm","algoVisualizer","visitedNodesInOrder","nodesInShortestPathOrder","setState","length","i","setTimeout","node","document","getElementById","running","animateShortestPath","oldClasses","getAllNodes","grid","nodes","push","getUnvisitedNeighbors","neighbors","filter","neighbor","isVisited","getNodesInShortestPathOrder","finishNode","currentNode","unshift","previousNode","clearPath","callback","distance","Infinity","createNode","isPathDrawn","heuristic","randomInteger","min","max","Math","floor","random","resetGrid","startNodeCoords","finishNodeCoords","getInitialGrid","currentRow","startRow","startCol","finishRow","finishCol","getEuclideanDistance","x1","y1","x2","y2","a","b","sqrt","getRandomEmptyNodeCoords","emptyNodes","newRow","nodeRow","updateUnvisitedNeighbors","unvisitedNeighbors","visualizeDijkstra","startTime","Date","getTime","startNode","visitedNodes","unvisitedNodes","sort","nodeA","nodeB","closestNode","shift","computeDijkstra","computeAStar","abs","getGridWithHeuristics","updateneighbors","getNeighbors","visualizeDFS","computeDFS","unvisitedNeighbor","newVisitedNodes","visualizeBFS","queue","path","includes","computeBFS","visualizeRecursiveDivision","generatedWallsInOrder","computeRecursiveDivision","chamber","slice","wallLineRow","entranceIdx","newTopChamber","newBottomChamber","currentRowTopChamber","currentRowBottomChamber","wallLineCol","newLeftChamber","newRightChamber","currentRowLeftChamber","currentRowRightChamber","delay","animateGeneration","setWalls","walls","newNode","AlgoVisualizer","dragging","newGrid","getWallUpdatedGrid","enteredNodeType","randomEmptyNodeCoords","getNodeUpdatedGrid","startNodeRow","finishNodeRow","disabled","onClick","visualizeAStar","randomizeStartFinishNodes","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"mWAIqBA,G,wDACjB,WAAYC,GAAQ,IAAD,8BACf,cAAMA,IACDC,MAAQ,GAFE,E,qDAKT,IAAD,EASDC,KAAKF,MAPLG,EAFC,EAEDA,IACAC,EAHC,EAGDA,IACAC,EAJC,EAIDA,KACAC,EALC,EAKDA,YACAC,EANC,EAMDA,aACAC,EAPC,EAODA,UACAC,EARC,EAQDA,aAGEC,EAAqB,eAATL,EACZ,cACS,cAATA,EACA,aACS,aAATA,EACA,YACA,GAEN,OACI,yBACIM,GAAE,eAAUR,EAAV,YAAiBC,GACnBQ,UAAS,eAAYF,GACrBJ,YAAa,kBAAMA,EAAYH,EAAKC,IACpCG,aAAc,kBAAMA,EAAaJ,EAAKC,IACtCK,aAAc,kBAAMA,EAAaN,EAAKC,IACtCI,UAAW,kBAAMA,EAAUL,EAAKC,KAAM,yBAAKQ,UAAU,qB,GAhCnCC,cCAbC,G,wDACjB,WAAYd,GAAQ,IAAD,8BACf,cAAMA,IACDC,MAAQ,GAFE,E,qDAKT,IAAD,EAODC,KAAKF,MALLe,EAFC,EAEDA,kBACAC,EAHC,EAGDA,eACAC,EAJC,EAIDA,eACAC,EALC,EAKDA,gBACAC,EANC,EAMDA,SAGJ,OACI,yBAAKR,GAAG,kBAAkBC,UAAU,mBACxB,uBAAGA,UAAU,QAAO,mDAApB,IAAiDG,GACjD,uBAAGH,UAAU,QAAO,iDAApB,IAA+CI,EAA/C,MACA,uBAAGJ,UAAU,QAAO,6CAApB,IAA2CK,GAC3C,uBAAGL,UAAU,QAAO,6CAApB,IAA2CM,GAC3C,uBAAGN,UAAU,QAAO,qCAApB,IAAmCO,Q,GArBxBN,c,QCAdO,G,wDACjB,WAAYpB,GAAQ,IAAD,8BACf,cAAMA,IACDC,MAAQ,GAFE,E,qDAQf,OAHM,YACKC,KAAKF,OAGZ,yBAAKW,GAAG,mBAAmBC,UAAU,oBACzB,uBAAGA,UAAU,eAAc,yBAAKA,UAAU,oBAAwB,sCAClE,uBAAGA,UAAU,eAAc,yBAAKA,UAAU,qBAAyB,uCACnE,uBAAGA,UAAU,eAAc,yBAAKA,UAAU,mBAAuB,qCACjE,uBAAGA,UAAU,eAAc,yBAAKA,UAAU,kCAAsC,wCAChF,uBAAGA,UAAU,eAAc,yBAAKA,UAAU,wCAA4C,qCACtF,uBAAGA,UAAU,eAAc,yBAAKA,UAAU,kCAAsC,wCAChF,uBAAGA,UAAU,eAAc,yBAAKA,UAAU,qBAAyB,+C,GAjBvDC,c,OCJ7B,SAASQ,EAAiBC,EAAgBC,EAAqBC,GAElEF,EAAeG,SAAS,CAAEP,gBAAiBK,EAAoBG,SAC/D,IAH4F,eAGnFC,GACL,GAAIA,IAAMJ,EAAoBG,OAK1B,OAHAE,YAAW,YAoBvB,SAA6BN,EAAgBE,GAEF,IAApCA,EAAyBE,QAAcJ,EAAeG,SAAS,CAAER,eAAgBO,EAAyBE,SAC7G,IAHmE,eAG1DC,GACLC,YAAW,WACP,IAAMC,EAAOL,EAAyBG,GACtCG,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UACxDkB,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAAY,wBAN9D,GAOCe,IALNA,EAAI,EAAGA,EAAIH,EAAyBE,OAAQC,IAAM,EAAlDA,GAOTC,YAAW,WAAKN,EAAeG,SAAS,CAACO,SAAS,MATpC,GASuDR,EAAyBE,QA7BlFO,CAAoBX,EAAgBE,KANlC,GAOKG,GACL,CAAN,UAGJC,YAAW,WACP,IAAMC,EAAON,EAAoBI,GAC7BO,EAAaJ,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAEzEkB,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAAYsB,EAAa,gBAEjFN,YAAW,WACPE,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAAYsB,EAAa,kBAlB/E,SAoBCP,IAlBNA,EAAI,EAAGA,GAAKJ,EAAoBG,OAAQC,IAAK,CAAC,IAAD,IAA7CA,GAA6C,mCAyDnD,SAASQ,EAAYC,GAC1B,IADgC,EAC1BC,EAAQ,GADkB,cAEdD,GAFc,IAEhC,2BAAwB,CAAC,IAAD,EAAbjC,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAd0B,EAAa,QACtBQ,EAAMC,KAAKT,IAFS,gCAFQ,8BAOhC,OAAOQ,EAGF,SAASE,EAAsBV,EAAMO,GACxC,IAAMI,EAAY,GACXrC,EAAY0B,EAAZ1B,IAAKC,EAAOyB,EAAPzB,IAOZ,OALGD,EAAM,GAAGqC,EAAUF,KAAKF,EAAKjC,EAAI,GAAGC,IACpCD,EAAM,EAAIiC,EAAKV,QAAQc,EAAUF,KAAKF,EAAKjC,EAAM,GAAGC,IACpDA,EAAM,GAAGoC,EAAUF,KAAKF,EAAKjC,GAAKC,EAAI,IACtCA,EAAM,EAAIgC,EAAK,GAAGV,QAAQc,EAAUF,KAAKF,EAAKjC,GAAKC,EAAM,IAErDoC,EAAUC,QAAO,SAAAC,GAAQ,OAAKA,EAASC,aAe3C,SAASC,EAA4BC,GAGxC,IAFA,IAAMrB,EAA2B,GAC7BsB,EAAcD,EACK,OAAhBC,GACHtB,EAAyBuB,QAAQD,GACjCA,EAAcA,EAAYE,aAE9B,OAAOxB,EA4BJ,SAASyB,EAAU3B,GAAgC,IAAD,EAAf4B,EAAe,uDAAN,KAC1Cd,EAAQd,EAAerB,MAAvBmC,KADgD,cAGpCA,GAHoC,IAGrD,IAAI,EAAJ,qBAAuB,CAAC,IAAD,EAAbjC,EAAa,sBACHA,GADG,IACnB,IAAI,EAAJ,qBAAoB,CAAC,IAAb0B,EAAY,QAEZsB,EAAyB,cAAdtB,EAAKxB,KAAuB,EAAI+C,IAC/ChB,EAAKP,EAAK1B,KAAK0B,EAAKzB,KAAOiD,EAAWxB,EAAK1B,IAAK0B,EAAKzB,IAAKyB,EAAKxB,KAAM8C,GAEpD,YAAdtB,EAAKxB,OACJyB,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAAY,SAPzD,gCAH8B,8BAcrDU,EAAeG,SAAS,CAAEW,OAAMkB,aAAa,EAAOrC,eAAgB,EAAGC,gBAAiB,GAAKgC,GAG1F,SAASG,EAAWlD,EAAKC,EAAKC,EAAM8C,GACvC,MAAO,CACHhD,MACAC,MACAC,OACA8C,WACAI,UAAW,EACXZ,WAAW,EACXK,aAAc,MAIf,SAASQ,EAAcC,EAAKC,GAC/B,OAAOC,KAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,IAAMA,EAalD,SAASK,EAAUxC,EAAgB4B,GAAW,IAAD,IACA5B,EAAerB,MAA1DmC,EAD2C,EAC3CA,KAAM2B,EADqC,EACrCA,gBAAiBC,EADoB,EACpBA,iBADoB,cAI9B5B,GAJ8B,IAIhD,2BAAwB,CAAC,IAAD,EAAbjC,EAAa,sBACDA,GADC,IACpB,2BAAwB,CAAC,IAAd0B,EAAa,QACpBC,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAAY,QAFpD,gCAJwB,8BAWhDkB,SAASC,eAAT,eAAgCgC,EAAgB,GAAhD,YAAsDA,EAAgB,KAAMnD,UAAY,kBACxFkB,SAASC,eAAT,eAAgCiC,EAAiB,GAAjD,YAAuDA,EAAiB,KAAMpD,UAAY,mBAC1FwB,EAAO6B,EAAe3C,GACtBA,EAAeG,SAAS,CAAEW,OAAMjB,SAAU,EAAGF,eAAgB,EAAGC,gBAAiB,GAAKgC,GAGnF,SAASe,EAAe3C,GAK3B,IAHA,IAAMc,EAAO,GAGJjC,EAAM,EAAGA,EAFE,GAEiBA,IAAO,CAExC,IADA,IAAM+D,EAAa,GACV9D,EAAM,EAAGA,EAHF,GAGqBA,IACjC8D,EAAW5B,KAAKe,EAAWlD,EAAKC,EAAK,UAAWgD,MAEpDhB,EAAKE,KAAK4B,GAV4B,kBAcb5C,EAAerB,MAAM8D,gBAdR,GAcnCI,EAdmC,KAczBC,EAdyB,mBAeX9C,EAAerB,MAAM+D,iBAfV,GAenCK,EAfmC,KAexBC,EAfwB,KAkB1C,OAFAlC,EAAK+B,GAAUC,GAAYf,EAAWc,EAAUC,EAAU,YAAa,GACvEhC,EAAKiC,GAAWC,GAAajB,EAAWgB,EAAWC,EAAW,aAAclB,KACrEhB,EAGJ,SAASmC,EAAqBC,EAAIC,EAAIC,EAAIC,GAC7C,IAAIC,EAAIJ,EAAKE,EACTG,EAAIJ,EAAKE,EACb,OAAOhB,KAAKmB,KAAMF,EAAEA,EAAIC,EAAEA,GAGvB,SAASE,EAAyBzD,GAAgB,IAAD,EAC/Cc,EAAQd,EAAerB,MAAvBmC,KACD4C,EAAa,GAFmC,cAIrC5C,GAJqC,IAIpD,IAAI,EAAJ,qBAAoB,CAAC,IACb6C,EADY,QACCxC,QAAO,SAAAZ,GAAI,MAAkB,YAAdA,EAAKxB,QAClC4E,EAAOvD,OAAS,GAAGsD,EAAW1C,KAAK2C,IANU,8BASpD,GAAGD,EAAWtD,OAAS,EAAG,CACtB,IAAIwD,EAAU1B,EAAc,EAAGwB,EAAWtD,OAAS,GAC/CG,EAAOmD,EAAWE,GAAS1B,EAAc,EAAGwB,EAAWE,GAASxD,OAAS,IAC7E,MAAO,CAACG,EAAK1B,IAAK0B,EAAKzB,MCxM/B,SAAS+E,EAAyBtD,EAAMO,GACtC,IAD4C,EACtCgD,EAAqB7C,EAAsBV,EAAMO,GADX,cAErBgD,GAFqB,IAE5C,2BAA2C,CAAC,IAAjC1C,EAAgC,QACzCA,EAASS,SAAWtB,EAAKsB,SAAW,EACpCT,EAASM,aAAenB,GAJkB,+BAQvC,SAASwD,EAAkB/D,EAAgBc,EAAM2B,EAAiBC,GACvE1C,EAAeG,SAAS,CAACO,SAAS,IAClCiB,EAAU3B,GACV,IAAIgE,GAAY,IAAIC,MAAOC,UACrBjE,EAtCD,SAAyBa,EAAM2B,EAAiBC,GACrD,IAAMyB,EAAYrD,EAAK2B,EAAgB,IAAIA,EAAgB,IACrDlB,EAAaT,EAAK4B,EAAiB,IAAIA,EAAiB,IAC9DyB,EAAUtC,SAAW,EAIrB,IAHA,IAAIuC,EAAe,GACbC,EAAiBxD,EAAYC,GAE7BuD,EAAejE,QAAO,CAEJiE,ED8FhBC,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAM1C,SAAW2C,EAAM3C,YC5FlD,IAAI4C,EAAcJ,EAAeK,QAGjC,GAAwB,aAArBD,EAAY1F,KAAf,CAEA,GAAI0F,EAAY5C,WAAaC,IAAU,OAAOsC,EAK9C,GAJAK,EAAYpD,WAAY,EACxB+C,EAAapD,KAAKyD,GAGfA,IAAgBlD,EAAY,OAAO6C,EACtCP,EAAyBY,EAAa3D,KAgBd6D,CAAgB7D,EAAM2B,EAAiBC,GAC7DxC,EAA2BoB,EAA4BR,EAAK4B,EAAiB,IAAIA,EAAiB,KACpGhD,GAAiB,IAAIuE,MAAOC,UAAYF,EAC5CjE,EAAiBC,EAAgBC,EAAqBC,GACtDF,EAAeG,SAAS,CAAE6B,aAAa,EAAMtC,iBAAgBD,kBAAmB,aC1C3E,SAASmF,EAAa9D,EAAM2B,EAAiBC,GAChD,IAAMyB,EAAYrD,EAAK2B,EAAgB,IAAIA,EAAgB,IACrDlB,EAAaT,EAAK4B,EAAiB,IAAIA,EAAiB,IAC9D5B,EAqDJ,SAA+BA,EAAMS,GAAmC,IAAD,EAAtBU,EAAsB,uDAAZ,YAAY,cACjDnB,GADiD,IACnE,2BAAwB,CAAC,IAAD,EAAbjC,EAAa,sBACDA,GADC,IACpB,2BAAwB,CAAC,IAAd0B,EAAa,QACH,cAAd0B,EAEC1B,EAAK0B,UAAYI,KAAKwC,IAAItE,EAAK1B,IAAM0C,EAAW1C,KAAOwD,KAAKwC,IAAItE,EAAKzB,IAAMyC,EAAWzC,KAClE,cAAdmD,IAEN1B,EAAK0B,UAAYgB,EAAqB1C,EAAK1B,IAAK0B,EAAKzB,IAAKyC,EAAW1C,IAAK0C,EAAWzC,OAPzE,gCAD2C,8BAYnE,OAAOgC,EAjEAgE,CAAsBhE,EAAMS,EAAY,aAC/C4C,EAAUtC,SAAW,EAIrB,IAHA,IAAIuC,EAAe,GACbC,EAAiBxD,EAAYC,GAE7BuD,EAAejE,QAAO,CAEQiE,EFiG9BC,MAAK,SAAUC,EAAOC,GAExB,OAAGD,EAAM1C,SAAW2C,EAAM3C,SACf,EACA0C,EAAM1C,SAAW2C,EAAM3C,UACtB,EAIL0C,EAAMtC,UAAYuC,EAAMvC,UAChB,EACAsC,EAAMtC,UAAYuC,EAAMvC,WACvB,EAED,KE7Gf,IAAIwC,EAAcJ,EAAeK,QAEjC,GAAwB,aAArBD,EAAY1F,KAAf,CAEA,GAAI0F,EAAY5C,WAAaC,IAAU,OAAOsC,EAK9C,GAJAK,EAAYpD,WAAY,EACxB+C,EAAapD,KAAKyD,GAGfA,IAAgBlD,EAAY,OAAO6C,EACtCW,EAAgBN,EAAa3D,KAerC,SAASiE,EAAgBxE,EAAMO,GAC3B,IADiC,EAC3BI,EF0CH,SAAsBX,EAAMO,GAC/B,IAAMI,EAAY,GACXrC,EAAY0B,EAAZ1B,IAAKC,EAAOyB,EAAPzB,IAOZ,OALGD,EAAM,GAAGqC,EAAUF,KAAKF,EAAKjC,EAAI,GAAGC,IACpCD,EAAM,EAAIiC,EAAKV,QAAQc,EAAUF,KAAKF,EAAKjC,EAAM,GAAGC,IACpDA,EAAM,GAAGoC,EAAUF,KAAKF,EAAKjC,GAAKC,EAAI,IACtCA,EAAM,EAAIgC,EAAK,GAAGV,QAAQc,EAAUF,KAAKF,EAAKjC,GAAKC,EAAM,IAErDoC,EEnDW8D,CAAazE,EAAMO,GADJ,cAGVI,GAHU,IAGjC,2BAAkC,CAAC,IAAxBE,EAAuB,QAC3BA,EAASC,UACLD,EAASS,SAAWT,EAASa,UAAY1B,EAAKmB,aAAaG,SAAWtB,EAAKmB,aAAaO,YACvF1B,EAAKmB,aAAeN,IAGH,IAAlBb,EAAKsB,SACJT,EAASS,SARN,EAQ0BT,EAASa,UAEtCb,EAASS,SAAWtB,EAAKsB,SAAWtB,EAAK0B,UAVtC,EAU2Db,EAASa,UAE3Eb,EAASM,aAAenB,IAdC,+BCvB9B,SAAS0E,EAAajF,EAAgBc,EAAM2B,EAAiBC,GAChE1C,EAAeG,SAAS,CAACO,SAAS,IAClCiB,EAAU3B,GACV,IAAMmE,EAAYrD,EAAK2B,EAAgB,IAAIA,EAAgB,IACrDlB,EAAaT,EAAK4B,EAAiB,IAAIA,EAAiB,IAC1DsB,GAAY,IAAIC,MAAOC,UACrBjE,EApBV,SAASiF,EAAWpE,EAAMU,EAAaD,EAAY6C,GAG/C,GAFAA,EAAapD,KAAKQ,GAClBA,EAAYH,WAAY,EACrBG,IAAgBD,EAAY,MAAO,CAAC6C,EAAcA,GAHQ,oBAIhCnD,EAAsBO,EAAaV,GAAMK,QAAO,SAAAC,GAAQ,MAAsB,aAAlBA,EAASrC,SAJrC,IAI7D,IAAI,EAAJ,qBAAwH,CAAC,IAAjHoG,EAAgH,QACpH,IAAIA,EAAkB9D,UAAU,CAC5B8D,EAAkBzD,aAAeF,EACjC,IAAI4D,EAAkBF,EAAWpE,EAAMqE,EAAmB5D,EAAY6C,GAAc,GACpF,GAAGgB,EAAiB,MAAO,CAACA,EAAiBA,KARQ,8BAW7D,MAAO,CAAC,KAAMhB,GAScc,CAAWpE,EAAMqD,EAAW5C,EAAY,IAAI,GAClErB,EAA2BoB,EAA4BR,EAAK4B,EAAiB,IAAIA,EAAiB,KACpGhD,GAAiB,IAAIuE,MAAOC,UAAYF,EACzC/D,EAAqBF,EAAiBC,EAAgBC,EAAqBC,GAAgCF,EAAeG,SAAS,CAACO,SAAS,IAChJV,EAAeG,SAAS,CAAC6B,aAAa,EAAMtC,iBAAgBD,kBAAmB,QCK5E,SAAS4F,EAAarF,EAAgBc,EAAM2B,EAAiBC,GAChE1C,EAAeG,SAAS,CAACO,SAAS,EAAMsB,aAAa,IACrDL,EAAU3B,GACV,IAAMmE,EAAYrD,EAAK2B,EAAgB,IAAIA,EAAgB,IACrDlB,EAAaT,EAAK4B,EAAiB,IAAIA,EAAiB,IAC1DsB,GAAY,IAAIC,MAAOC,UACrBjE,EAnCV,SAAoBa,EAAMqD,EAAW5C,GACjC,IAAI+D,EAAQ,CAACnB,GACToB,EAAO,CAACpB,GAGZ,GAFAA,EAAU9C,WAAY,EAEnB8C,IAAc5C,EAAY,OAAOgE,EAEpC,KAAMD,GAAM,CAGR,KAFAnB,EAAYmB,EAAMZ,SAcd,OAAOa,EAZG,IAAD,gBACWtE,EAAsBkD,EAAWrD,GAAMK,QAAO,SAAAC,GAAQ,MAAsB,aAAlBA,EAASrC,SAD9E,IACT,IAAI,EAAJ,qBAA4G,CAAC,IAArGqC,EAAoG,QACxG,IAAImE,EAAKC,SAASpE,KACdA,EAASM,aAAeyC,EACxB/C,EAASC,WAAY,EACrBkE,EAAKvE,KAAKI,GACVkE,EAAMtE,KAAKI,GAERA,IAAaG,GAAY,OAAOgE,GARlC,+BAgBjB,OAAOA,EASqBE,CAAW3E,EAAMqD,EAAW5C,GAClDrB,EAA2BoB,EAA4BR,EAAK4B,EAAiB,IAAIA,EAAiB,KACpGhD,GAAiB,IAAIuE,MAAOC,UAAYF,EAC5CjE,EAAiBC,EAAgBC,EAAqBC,GACtDF,EAAeG,SAAS,CAAC6B,aAAa,EAAMtC,iBAAgBD,kBAAmB,Q,MCiD5E,SAASiG,EAA2B1F,EAAgBc,EAAM2B,EAAiBC,GAC9E1C,EAAeG,SAAS,CAACO,SAAS,IAClC8B,EAAUxC,GAAgB,WACtB,IAAIgE,GAAY,IAAIC,MAAOC,UAErByB,EA7FP,SAASC,EAAyBC,EAASpD,EAAiBC,EAAkBiD,GAKjF,GAAGE,EAAQzF,QAHc,GAGgByF,EAAQ,GAAGzF,QAH3B,EAIrB,OAAOuF,EAIX,GAAoC,IAAjCA,EAAsBvF,OAAc,CACnC,IAAI,IAAIvB,EAAM,EAAGA,EAAMgH,EAAQzF,OAAQvB,IACnC,IAAI,IAAIC,EAAM,EAAGA,EAAM+G,EAAQ,GAAGzF,OAAQtB,IAC3B,IAARD,GAAqB,IAARC,GAAaD,IAAQgH,EAAQzF,OAAS,GAAKtB,IAAQ+G,EAAQ,GAAGzF,OAAS,GACrD,YAA3ByF,EAAQhH,GAAKC,GAAKC,MAAiD,aAA3B8G,EAAQhH,GAAKC,GAAKC,MAAqB4G,EAAsB3E,KAAK6E,EAAQhH,GAAKC,IAItI+G,EAAUA,EAAQC,MAAM,EAAGD,EAAQzF,OAAS,GAC5C,IAAQvB,EAAM,EAAGA,EAAMgH,EAAQzF,OAAQvB,IACnCgH,EAAQhH,GAAOgH,EAAQhH,GAAKiH,MAAM,EAAGD,EAAQhH,GAAKuB,OAAS,GAKnE,GAAGyF,EAAQzF,OAASyF,EAAQ,GAAGzF,OAAO,CAGlC,IAAI2F,EAAc7D,EAAc,EAAG2D,EAAQzF,OAAS,GAEhD4F,EAAsC,IAAxB9D,EAAc,EAAG,GAAW,EAAI2D,EAAQ,GAAGzF,OAAS,EAEtE,IAAQtB,EAAM,EAAGA,EAAM+G,EAAQE,GAAa3F,OAAQtB,IAC7CA,IAAQkH,GAAeH,EAAQE,GAAajH,IAA2C,cAAnC+G,EAAQE,GAAajH,GAAKC,MAA2D,eAAnC8G,EAAQE,GAAajH,GAAKC,MAAuB4G,EAAsB3E,KAAK6E,EAAQE,GAAajH,IAK9M,IAAImH,EAAgB,GAChBC,EAAmB,GACvB,IAAQrH,EAAM,EAAGA,EAAMgH,EAAQzF,OAAQvB,IAAM,CACzC,IAAMsH,EAAuB,GACvBC,EAA0B,GAChC,IAAQtH,EAAM,EAAGA,EAAM+G,EAAQ,GAAGzF,OAAQtB,IACnCD,EAAMkH,GAAaI,EAAqBnF,KAAK6E,EAAQhH,GAAKC,IAC1DD,EAAMkH,GAAaK,EAAwBpF,KAAK6E,EAAQhH,GAAKC,IAEjC,IAAhCqH,EAAqB/F,QAAc6F,EAAcjF,KAAKmF,GACnB,IAAnCC,EAAwBhG,QAAc8F,EAAiBlF,KAAKoF,GAInET,EAAwBC,EAAyBK,EAAexD,EAAiBC,EAAkBiD,GACnGA,EAAwBC,EAAyBM,EAAkBzD,EAAiBC,EAAkBiD,OAEnG,CAGH,IAAIU,EAAcnE,EAAc,EAAG2D,EAAQ,GAAGzF,OAAS,GAIvD,IAFI4F,EAAsC,IAAxB9D,EAAc,EAAG,GAAW,EAAI2D,EAAQzF,OAAS,EAE3DvB,EAAM,EAAGA,EAAMgH,EAAQzF,OAAQvB,IAChCA,IAAQmH,GAAeH,EAAQhH,GAAKwH,IAAmD,cAAnCR,EAAQhH,GAAKwH,GAAatH,MAA2D,eAAnC8G,EAAQhH,GAAKwH,GAAatH,MAAuB4G,EAAsB3E,KAAK6E,EAAQhH,GAAKwH,IAKtM,IAAIC,EAAiB,GACjBC,EAAkB,GACtB,IAAQ1H,EAAM,EAAGA,EAAMgH,EAAQzF,OAAQvB,IAAM,CACzC,IAAM2H,EAAwB,GACxBC,EAAyB,GAC/B,IAAQ3H,EAAM,EAAGA,EAAM+G,EAAQ,GAAGzF,OAAQtB,IACnCA,EAAMuH,GAAaG,EAAsBxF,KAAK6E,EAAQhH,GAAKC,IAC3DA,EAAMuH,GAAaI,EAAuBzF,KAAK6E,EAAQhH,GAAKC,IAEnEwH,EAAetF,KAAKwF,GACpBD,EAAgBvF,KAAKyF,GAGzBd,EAAwBC,EAAyBU,EAAgB7D,EAAiBC,EAAkBiD,GACpGA,EAAwBC,EAAyBW,EAAiB9D,EAAiBC,EAAkBiD,GAGzG,OAAOA,EAQ2BC,CAAyB9E,EAAM2B,EAAiBC,EAAkB,IAC5FhD,GAAiB,IAAIuE,MAAOC,UAAYF,EAC5ChE,EAAeG,SAAS,CAAET,iBAAgBD,kBAAmB,uBL1D9D,SAA2BO,EAAgB2F,GAG9C,IAHqF,IAAhB/D,EAAe,uDAAN,KACtEd,EAASd,EAAerB,MAAxBmC,KACF4F,EAAQ,GAFsE,WAG3ErG,GACLC,YAAW,WACP,IAAMC,EAAOoF,EAAsBtF,GAC/BO,EAAaJ,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAEzEkB,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAAYsB,EAAa,gBAEjFN,YAAW,WACPE,SAASC,eAAT,eAAgCF,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOQ,UAAYsB,EAAa,eAClF8F,KACJA,EAAQrG,IAVNA,EAAI,EAAGA,EAAIsF,EAAsBvF,OAAQC,IAAM,EAA/CA,GAYTC,YAAW,WACPN,EAAeG,SAAS,CAACO,SAAS,IAC/BkB,GAAUA,EAAS5B,EAAgBc,EAAM6E,KAC7Ce,EAAQf,EAAsBvF,QKyC7BuG,CAAkB3G,EAAgB2F,EAAuBiB,MAIjE,SAASA,EAAS5G,EAAgBc,EAAM+F,GAAO,IAAD,gBAC1BA,GAD0B,IAC1C,IAAI,EAAJ,qBAAsB,CAAC,IAAftG,EAAc,QACZuG,EAAO,2BACNvG,GADM,IAETxB,KAAM,aAEV+B,EAAKP,EAAK1B,KAAK0B,EAAKzB,KAAOgI,GANW,8BAQ1C9G,EAAeG,SAAS,CAAEW,OAAMjB,SAAUgH,EAAMzG,S,ICjG/B2G,E,kDACjB,WAAYrI,GAAQ,IAAD,8BACf,cAAMA,IACDC,MAAQ,CACTmC,KAAM,GACN2B,gBAAiB,CAAC,EAAG,IACrBC,iBAAkB,CAAC,EAAG,IACtBhC,SAAS,EACTsG,SAAU,GACVhF,aAAa,EACbvC,kBAAmB,GACnBC,eAAgB,EAChBC,eAAgB,EAChBC,gBAAiB,EACjBC,SAAU,GAbC,E,gEAkBf,IAAMiB,EAAO6B,EAAe/D,MAC5BA,KAAKuB,SAAS,CAACW,W,sCAGHjC,EAAKC,GACjB,IAAIC,EAAOH,KAAKD,MAAMmC,KAAKjC,GAAKC,GAAKC,KACjCc,EAAWjB,KAAKD,MAAMkB,SAC1B,IAAIjB,KAAKD,MAAM+B,QACX,GAAY,cAAT3B,EACCH,KAAKuB,SAAS,CAAE6G,SAAU,mBACvB,GAAY,eAATjI,EACNH,KAAKuB,SAAS,CAAE6G,SAAU,mBACvB,CACHnH,EAAoB,aAATd,EAAsBc,EAAW,EAAIA,EAAW,EAC3D,IAAMoH,EAAUC,EAAmBtI,KAAKD,MAAMmC,KAAMjC,EAAKC,GACzDF,KAAKuB,SAAS,CAAEW,KAAMmG,EAASD,SAAU,WAAYnH,gB,uCAKhDhB,EAAKC,GAClB,IAAMqI,EAAkBvI,KAAKD,MAAMmC,KAAKjC,GAAKC,GAAKC,KAC9CkI,EAAUrI,KAAKD,MAAMmC,KACrBjB,EAAWjB,KAAKD,MAAMkB,SAE1B,GAA4B,MAAxBjB,KAAKD,MAAMqI,WACXpI,KAAKD,MAAM+B,QACX,GAA2B,cAAxB9B,KAAKD,MAAMqI,SAAyB,CACnC,GAAuB,eAApBG,EAAiC,CAChC,IAAMC,EAAwB3D,EAAyB7E,MACvDqI,EAAUI,EAAmBJ,EAASG,EAAsB,GAAIA,EAAsB,GAAI,cAC1FxI,KAAKuB,SAAS,CAAEuC,iBAAkB0E,QACR,aAApBD,IACNtH,GAAY,GAEhBoH,EAAUI,EAAmBJ,EAASpI,EAAKC,EAAK,aAChDF,KAAKuB,SAAS,CAAEW,KAAMmG,EAASpH,kBAC5B,GAA2B,eAAxBjB,KAAKD,MAAMqI,SAA2B,CAC5C,GAAuB,cAApBG,EAAgC,CAC/B,IAAMC,EAAwB3D,EAAyB7E,MACvDqI,EAAUI,EAAmBJ,EAASG,EAAsB,GAAIA,EAAsB,GAAI,aAC1FxI,KAAKuB,SAAS,CAAEsC,gBAAiB2E,QACP,aAApBD,IACNtH,GAAY,GAEhBoH,EAAUI,EAAmBJ,EAASpI,EAAKC,EAAK,cAChDF,KAAKuB,SAAS,CAAEW,KAAMmG,EAASpH,iBAED,aAAxBjB,KAAKD,MAAMqI,WACjBnH,EAA+B,aAApBsH,EAAiCtH,EAAW,EAAIA,EAAW,EACtEoH,EAAUC,EAAmBD,EAASpI,EAAKC,GAC3CF,KAAKuB,SAAS,CAAEW,KAAMmG,EAASpH,gB,uCAK1BhB,EAAKC,GAClB,IAAIF,KAAKD,MAAM+B,UACgB,cAAxB9B,KAAKD,MAAMqI,UAAoD,eAAxBpI,KAAKD,MAAMqI,UAA0B,CACxEpI,KAAKD,MAAMqD,aACVL,EAAU/C,MAEd,IAAMqI,EAAUI,EAAmBzI,KAAKD,MAAMmC,KAAMjC,EAAKC,EAAK,WAC9DF,KAAKuB,SAAS,CAAEW,KAAMmG,O,oCAKpBpI,EAAKC,GACf,IAAIF,KAAKD,MAAM+B,QACX,GAA2B,cAAxB9B,KAAKD,MAAMqI,SAAyB,CACnC,IAAMC,EAAUI,EAAmBzI,KAAKD,MAAMmC,KAAMjC,EAAKC,EAAK,aAC9DF,KAAKuB,SAAS,CAAEW,KAAMmG,EAASD,SAAU,GAAIvE,gBAAiB,CAAC5D,EAAKC,UACjE,GAA2B,eAAxBF,KAAKD,MAAMqI,SAA2B,CAC5C,IAAMC,EAAUI,EAAmBzI,KAAKD,MAAMmC,KAAMjC,EAAKC,EAAK,cAC9DF,KAAKuB,SAAS,CAAEW,KAAMmG,EAASD,SAAU,GAAItE,iBAAkB,CAAC7D,EAAKC,KAI7EF,KAAKuB,SAAS,CAAE6G,SAAU,O,kDAGD,IAAD,EACyBpI,KAAKD,MAAjDmC,EADmB,EACnBA,KAAM2B,EADa,EACbA,gBAAiBC,EADJ,EACIA,iBAE5B5B,EAAK2B,EAAgB,IAAIA,EAAgB,IAAMV,EAAWU,EAAgB,GAAIA,EAAgB,GAAI,UAAWX,KAC7GhB,EAAK4B,EAAiB,IAAIA,EAAiB,IAAMX,EAAWW,EAAiB,GAAIA,EAAiB,GAAI,UAAWZ,KAEjH,IANwB,EAMpB4B,EAAa,GANO,cAQT5C,GARS,IAQxB,IAAI,EAAJ,qBAAoB,CAAC,IACb6C,EADY,QACCxC,QAAO,SAAAZ,GAAI,MAAkB,YAAdA,EAAKxB,QAClC4E,EAAOvD,OAAS,GAAGsD,EAAW1C,KAAK2C,IAVlB,8BAaxB,GAAGD,EAAWtD,OAAS,EAAG,CACtB,IAAIkH,EAAepF,EAAc,EAAGwB,EAAWtD,OAAS,GACpD+D,EAAYT,EAAW4D,GAAcpF,EAAc,EAAGwB,EAAW4D,GAAclH,OAAS,IACxFmH,EAAgBrF,EAAc,EAAGwB,EAAWtD,OAAS,GACrDmB,EAAamC,EAAW6D,GAAerF,EAAc,EAAGwB,EAAW6D,GAAenH,OAAS,IAE/FqC,EAAkB,CAAC0B,EAAUtF,IAAKsF,EAAUrF,KAC5C4D,EAAmB,CAACnB,EAAW1C,IAAK0C,EAAWzC,KAE/CgC,EAAK2B,EAAgB,IAAIA,EAAgB,IAAMV,EAAWU,EAAgB,GAAIA,EAAgB,GAAI,YAAa,GAC/G3B,EAAK4B,EAAiB,IAAIA,EAAiB,IAAMX,EAAWW,EAAiB,GAAIA,EAAiB,GAAI,aAAcZ,KAEpHlD,KAAKuB,SAAS,CAAEW,OAAM2B,kBAAiBC,wB,+BAIrC,IAAD,SAC2H9D,KAAKD,MAA9HmC,EADF,EACEA,KAAM2B,EADR,EACQA,gBAAiBC,EADzB,EACyBA,iBAAkBhD,EAD3C,EAC2CA,eAAgBC,EAD3D,EAC2DA,eAAgBC,EAD3E,EAC2EA,gBAAiBC,EAD5F,EAC4FA,SAAUJ,EADtG,EACsGA,kBAE3G,OACI,6BACI,yBAAKH,UAAU,QACX,wBAAIA,UAAU,SAAd,0BACA,yBAAKA,UAAU,wBACX,yBAAKA,UAAU,cACX,2CACA,4BAAQA,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBAAM1D,EAAkB,EAAMjD,EAAM2B,EAAiBC,KAArI,wBACA,4BAAQpD,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBJ9HrG,SAAwBzH,EAAgBc,EAAM2B,EAAiBC,GAClE1C,EAAeG,SAAS,CAACO,SAAS,EAAMsB,aAAa,IACrDL,EAAU3B,GACV,IAAIgE,GAAY,IAAIC,MAAOC,UACrBjE,EAAsB2E,EAAa9D,EAAM2B,EAAiBC,GAC1DxC,EAA2BoB,EAA4BR,EAAK4B,EAAiB,IAAIA,EAAiB,KACpGhD,GAAiB,IAAIuE,MAAOC,UAAYF,EAC5CjE,EAAiBC,EAAgBC,EAAqBC,GACtDF,EAAeG,SAAS,CAAC6B,aAAa,EAAMtC,iBAAgBD,kBAAmB,OIsH+BiI,CAAe,EAAM5G,EAAM2B,EAAiBC,KAAlI,MACA,4BAAQpD,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBAAMxC,EAAa,EAAMnE,EAAM2B,EAAiBC,KAAhI,OACA,4BAAQpD,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBAAMpC,EAAa,EAAMvE,EAAM2B,EAAiBC,KAAhI,QAEJ,yBAAKpD,UAAU,cACX,0CACA,4BAAQA,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBAAM/B,EAA2B,EAAM5E,EAAM2B,EAAiBC,KAA9I,uBAEJ,yBAAKpD,UAAU,cACX,6CACA,4BAAQA,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBAAKjF,EAAU,KAA/F,eACA,4BAAQlD,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBAAK9F,EAAU,KAA/F,cACA,4BAAQrC,UAAU,uBAAuBkI,SAAU5I,KAAKD,MAAM+B,QAAS+G,QAAS,kBAAK9F,EAAU,EAAM,EAAKgG,6BAA1G,oCAKZ,yBAAKrI,UAAU,kBACX,kBAAC,EAAD,MACA,kBAAC,EAAD,CACII,eAAgBA,EAChBC,eAAgBA,EAChBC,gBAAiBA,EACjBC,SAAUA,EACVJ,kBAAmBA,IAEvB,yBAAKH,UAAU,QACVwB,EAAK8G,KAAI,SAAC/I,EAAKgJ,GACZ,OACI,yBAAKC,IAAKD,GACLhJ,EAAI+I,KAAI,SAACrH,EAAMwH,GAAa,IACjBlJ,EAA6B0B,EAA7B1B,IAAKC,EAAwByB,EAAxBzB,IAAKC,EAAmBwB,EAAnBxB,KAAM8C,EAAatB,EAAbsB,SACxB,OACI,kBAAC,EAAD,CACIiG,IAAKC,EACLzI,UAAU,OACVT,IAAKA,EACLC,IAAKA,EACLC,KAAMA,EACN8C,SAAUA,EACV7C,YAAa,SAACH,EAAKC,GAAN,OAAc,EAAKkJ,gBAAgBnJ,EAAKC,IACrDG,aAAc,SAACJ,EAAKC,GAAN,OAAc,EAAKmJ,iBAAiBpJ,EAAKC,IACvDI,UAAW,SAACL,EAAKC,GAAN,OAAc,EAAKoJ,cAAcrJ,EAAKC,IACjDK,aAAc,SAACN,EAAKC,GAAN,OAAc,EAAKqJ,iBAAiBtJ,EAAKC,oB,GAxL3DS,aAsM5C,SAAS2H,EAAmBpG,EAAMjC,EAAKC,GACnC,IAAMmI,EAAUnG,EAAKgF,QACfvF,EAAO0G,EAAQpI,GAAKC,GACpBgI,EAAO,2BACNvG,GADM,IAETxB,KAAoB,aAAdwB,EAAKxB,KAAsB,UAA0B,YAAdwB,EAAKxB,KAAqB,WAAawB,EAAKxB,OAG7F,OADAkI,EAAQpI,GAAKC,GAAOgI,EACbG,EAGX,SAASI,EAAmBvG,EAAMjC,EAAKC,EAAKC,GACxC,IAAMkI,EAAUnG,EAAKgF,QACfvF,EAAO0G,EAAQpI,GAAKC,GACpBgI,EAAO,2BACNvG,GADM,IAETxB,SAGJ,OADAkI,EAAQpI,GAAKC,GAAOgI,EACbG,ECzNImB,MARf,WACE,OACE,yBAAK9I,UAAU,OACb,kBAAC,EAAD,QCIc+I,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFpI,SAASC,eAAe,SDyHpB,kBAAmBoI,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.8b5b3fe5.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            type,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave\r\n        } = this.props;\r\n\r\n        const typeClass = type === \"finishNode\"\r\n            ? 'node-finish'\r\n            : type === \"startNode\"\r\n            ? 'node-start'\r\n            : type === \"wallNode\"\r\n            ? 'node-wall'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className = {`node ${typeClass}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseLeave={() => onMouseLeave(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}><div className='node-center'></div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\n\r\nimport './Stats.css';\r\n\r\nexport default class Stats extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            lastAlgoRunString,\r\n            runTimeSeconds,\r\n            numNodesInPath,\r\n            numVisitedNodes,\r\n            numWalls\r\n        } = this.props;\r\n\r\n        return (\r\n            <div id='stats-component' className=\"stats-component\">\r\n                        <p className=\"stat\"><b>Last Algorithm Run: </b> {lastAlgoRunString}</p>\r\n                        <p className=\"stat\"><b>Calculation Time: </b> {runTimeSeconds}ms</p>\r\n                        <p className=\"stat\"><b>Nodes in Path:</b> {numNodesInPath}</p>\r\n                        <p className=\"stat\"><b>Nodes Visited:</b> {numVisitedNodes}</p>\r\n                        <p className=\"stat\"><b>Walls:</b> {numWalls}</p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\nimport './Legend.css';\r\nimport '../Node/Node.css';\r\n\r\nexport default class Legend extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {} = this.props;\r\n\r\n        return (\r\n            <div id='legend-component' className=\"legend-component\">\r\n                        <p className=\"legend-item\"><div className='node node-start'></div><b> Start</b></p>\r\n                        <p className=\"legend-item\"><div className='node node-finish'></div><b> Finish</b></p>\r\n                        <p className=\"legend-item\"><div className='node node-wall'></div><b> Wall</b></p>\r\n                        <p className=\"legend-item\"><div className='node node-visited node-legend'></div><b> Visited</b></p>\r\n                        <p className=\"legend-item\"><div className='node node-shortest-path node-legend'></div><b> Path</b></p>\r\n                        <p className=\"legend-item\"><div className='node node-current node-legend'></div><b> Current</b></p>\r\n                        <p className=\"legend-item\"><div className='node node-legend'></div><b> Unvisited</b></p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","export function animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const delay = 10;\r\n    algoVisualizer.setState({ numVisitedNodes: visitedNodesInOrder.length });\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        if (i === visitedNodesInOrder.length) {\r\n            // Animate the shortest path\r\n            setTimeout(() => {\r\n                animateShortestPath(algoVisualizer, nodesInShortestPathOrder);\r\n            }, delay * i);\r\n            return;\r\n        }\r\n        \r\n        setTimeout(() => {\r\n            const node = visitedNodesInOrder[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the visted nodes\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-visited';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    \r\n}\r\n\r\nfunction animateShortestPath(algoVisualizer, nodesInShortestPathOrder) {\r\n    const delay = 25;\r\n    if(nodesInShortestPathOrder.length !== 1) algoVisualizer.setState({ numNodesInPath: nodesInShortestPathOrder.length });\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = \r\n            document.getElementById(`node-${node.row}-${node.col}`).className + ' node-shortest-path';\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{algoVisualizer.setState({running: false});}, delay * nodesInShortestPathOrder.length);\r\n}\r\n\r\nexport function animateGeneration(algoVisualizer, generatedWallsInOrder, callback=null) {\r\n    const { grid } = algoVisualizer.state;\r\n    const delay = 10;\r\n    for (let i = 0; i < generatedWallsInOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = generatedWallsInOrder[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the walls\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-wall';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{\r\n        algoVisualizer.setState({running: false});\r\n        if(callback) callback(algoVisualizer, grid, generatedWallsInOrder);\r\n    }, delay * generatedWallsInOrder.length);\r\n}\r\n\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    var currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function sortNodesByDistance(nodes) {\r\n    nodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function sortNodesByDistanceAndHeuristic(nodes){\r\n    nodes.sort(function (nodeA, nodeB) {\r\n        // Sort on distance\r\n        if(nodeA.distance > nodeB.distance) {\r\n            return 1;\r\n        } else if (nodeA.distance < nodeB.distance) {\r\n            return -1;\r\n        } else {\r\n            // If the distances are the same,\r\n            // sort on distance - heuristic\r\n            if(nodeA.heuristic > nodeB.heuristic) {\r\n                return 1;\r\n            } else if (nodeA.heuristic < nodeB.heuristic) {\r\n                return -1;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function clearPath(algoVisualizer, callback=null) {\r\n    var {grid} = algoVisualizer.state;\r\n    \r\n    for(const row of grid) {\r\n        for(var node of row){\r\n            // update node values\r\n            var distance = node.type === \"startNode\" ? 0 : Infinity; \r\n            grid[node.row][node.col] = createNode(node.row, node.col, node.type, distance);\r\n            // update css class\r\n            if(node.type === \"default\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n            }\r\n        }\r\n    }\r\n    algoVisualizer.setState({ grid, isPathDrawn: false, numNodesInPath: 0, numVisitedNodes: 0 }, callback);\r\n}\r\n\r\nexport function createNode(row, col, type, distance) {\r\n    return {\r\n        row,\r\n        col,\r\n        type,\r\n        distance,\r\n        heuristic: 0,\r\n        isVisited: false,\r\n        previousNode: null\r\n    }\r\n}\r\n\r\nexport function randomInteger(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function randomEvenInteger(min, max) {\r\n    var temp =(Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2;\r\n    return temp;\r\n}\r\n\r\nexport function randomOddInteger(min, max) {\r\n    var temp = (Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2 + 1;\r\n    return temp;\r\n}\r\n\r\nexport function resetGrid(algoVisualizer, callback) {\r\n    var {grid, startNodeCoords, finishNodeCoords} = algoVisualizer.state;\r\n\r\n    // reset node classnames\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n        }\r\n    }\r\n\r\n    // set start and finish node classnames\r\n    document.getElementById(`node-${startNodeCoords[0]}-${startNodeCoords[1]}`).className = 'node node-start';\r\n    document.getElementById(`node-${finishNodeCoords[0]}-${finishNodeCoords[1]}`).className = 'node node-finish';\r\n    grid = getInitialGrid(algoVisualizer);\r\n    algoVisualizer.setState({ grid, numWalls: 0, numNodesInPath: 0, numVisitedNodes: 0 }, callback);\r\n}\r\n\r\nexport function getInitialGrid(algoVisualizer){\r\n    // Generate the empty grid\r\n    const grid = [];\r\n    const nodesPerRow = 20;\r\n    const nodesPerCol = 50;\r\n    for (let row = 0; row < nodesPerRow; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < nodesPerCol; col++) {\r\n            currentRow.push(createNode(row, col, \"default\", Infinity));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    // Set the start and finish nodes\r\n    const [startRow, startCol] = algoVisualizer.state.startNodeCoords;\r\n    const [finishRow, finishCol] = algoVisualizer.state.finishNodeCoords;\r\n    grid[startRow][startCol] = createNode(startRow, startCol, \"startNode\", 0);\r\n    grid[finishRow][finishCol] = createNode(finishRow, finishCol, \"finishNode\", Infinity);\r\n    return grid;\r\n};\r\n\r\nexport function getEuclideanDistance(x1, y1, x2, y2){\r\n    var a = x1 - x2;\r\n    var b = y1 - y2;\r\n    return Math.sqrt( a*a + b*b );\r\n}\r\n\r\nexport function getRandomEmptyNodeCoords(algoVisualizer){\r\n    var {grid} = algoVisualizer.state;\r\n    var emptyNodes = [];\r\n    // Get all empty nodes\r\n    for(var row of grid){\r\n        var newRow = row.filter(node => node.type === \"default\");\r\n        if(newRow.length > 0) emptyNodes.push(newRow);\r\n    }\r\n\r\n    if(emptyNodes.length > 0) {\r\n        var nodeRow = randomInteger(0, emptyNodes.length - 1);\r\n        var node = emptyNodes[nodeRow][randomInteger(0, emptyNodes[nodeRow].length - 1)];\r\n        return [node.row, node.col];\r\n    }\r\n}","import { animateAlgorithm, sortNodesByDistance, getAllNodes, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeDijkstra(grid, startNodeCoords, finishNodeCoords) {\r\n  const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n  const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n  startNode.distance = 0;\r\n  var visitedNodes = [];\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while(unvisitedNodes.length){\r\n      // Sort the nodes by distance\r\n      sortNodesByDistance(unvisitedNodes);\r\n      // Get the closest unvisited node\r\n      var closestNode = unvisitedNodes.shift();\r\n      // unvisitedNodes.unshift();\r\n      // Skip if the closest node is a wall\r\n      if(closestNode.type === \"wallNode\") continue;\r\n      // Return if there are no possible routes\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n\r\n      // Check if the current node is the finish node\r\n      if(closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nexport function visualizeDijkstra(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n  algoVisualizer.setState({running: true});\r\n  clearPath(algoVisualizer);\r\n  var startTime = new Date().getTime();\r\n  const visitedNodesInOrder = computeDijkstra(grid, startNodeCoords, finishNodeCoords);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  var runTimeSeconds = new Date().getTime() - startTime;\r\n  animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n  algoVisualizer.setState({ isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"Dijkstra\" });\r\n}\r\n\r\n\r\n","import { animateAlgorithm, sortNodesByDistanceAndHeuristic, getAllNodes, getNeighbors, getNodesInShortestPathOrder, clearPath, getEuclideanDistance } from '../helpers.js';\r\n\r\nexport function computeAStar(grid, startNodeCoords, finishNodeCoords) {\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    grid = getGridWithHeuristics(grid, finishNode, \"manhattan\");\r\n    startNode.distance = 0;\r\n    var visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(unvisitedNodes.length){\r\n        // Sort the nodes by distance\r\n        sortNodesByDistanceAndHeuristic(unvisitedNodes);\r\n        // Get the closest unvisited node\r\n        var closestNode = unvisitedNodes.shift();\r\n        // Skip if the closest node is a wall\r\n        if(closestNode.type === \"wallNode\") continue;\r\n        // Return if there are no possible routes\r\n        if (closestNode.distance === Infinity) return visitedNodes;\r\n        closestNode.isVisited = true;\r\n        visitedNodes.push(closestNode);\r\n\r\n        // Check if the current node is the finish node\r\n        if(closestNode === finishNode) return visitedNodes;\r\n        updateneighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nexport function visualizeAStar(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeAStar(grid, startNodeCoords, finishNodeCoords);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"A*\"});\r\n}\r\n\r\nfunction updateneighbors(node, grid) {\r\n    const neighbors = getNeighbors(node, grid);\r\n    const weight = 1;\r\n    for (const neighbor of neighbors) {\r\n        if(neighbor.isVisited){\r\n            if(neighbor.distance - neighbor.heuristic < node.previousNode.distance - node.previousNode.heuristic){\r\n                node.previousNode = neighbor;\r\n            }\r\n        } else {\r\n            if(node.distance === 0){\r\n                neighbor.distance = weight + neighbor.heuristic; \r\n            } else {\r\n                neighbor.distance = node.distance - node.heuristic + weight + neighbor.heuristic;\r\n            }\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getGridWithHeuristics(grid, finishNode, heuristic=\"manhattan\"){\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            if(heuristic === \"manhattan\"){\r\n                // Manhattan distance heuristic\r\n                node.heuristic = Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col);\r\n            } else if(heuristic === \"euclidean\") {\r\n                // Euclidean distance \r\n                node.heuristic = getEuclideanDistance(node.row, node.col, finishNode.row, finishNode.col);\r\n            }\r\n        }\r\n    }\r\n    return grid;\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nfunction computeDFS(grid, currentNode, finishNode, visitedNodes) {\r\n    visitedNodes.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) return [visitedNodes, visitedNodes];\r\n    for(let unvisitedNeighbor of getUnvisitedNeighbors(currentNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")) {\r\n        if(!unvisitedNeighbor.isVisited){\r\n            unvisitedNeighbor.previousNode = currentNode;\r\n            var newVisitedNodes = computeDFS(grid, unvisitedNeighbor, finishNode, visitedNodes)[0];\r\n            if(newVisitedNodes) return [newVisitedNodes, newVisitedNodes];\r\n        }\r\n    }\r\n    return [null, visitedNodes];\r\n}\r\n\r\nexport function visualizeDFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeDFS(grid, startNode, finishNode, [])[1];\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    if(visitedNodesInOrder) animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder); else algoVisualizer.setState({running: false});\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"DFS\"});\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nfunction computeBFS(grid, startNode, finishNode) {\r\n    var queue = [startNode];\r\n    var path = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    if(startNode === finishNode) return path;\r\n\r\n    while(queue){\r\n        startNode = queue.shift();\r\n\r\n        if(startNode){\r\n            for(var neighbor of getUnvisitedNeighbors(startNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")){\r\n                if(!path.includes(neighbor)){\r\n                    neighbor.previousNode = startNode;\r\n                    neighbor.isVisited = true;\r\n                    path.push(neighbor);\r\n                    queue.push(neighbor);\r\n    \r\n                    if(neighbor === finishNode) return path;\r\n                }\r\n            }\r\n        } else {\r\n            return path;\r\n        }\r\n\r\n    }\r\n    return path;\r\n}\r\n\r\nexport function visualizeBFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeBFS(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"BFS\"});\r\n}","import {resetGrid, randomInteger, animateGeneration} from '../helpers';\r\n\r\nexport function computeRecursiveDivision(chamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder){\r\n    \r\n    const min_chamber_size = 2;\r\n\r\n    // If minimum chamber size is reached, return the generated walls\r\n    if(chamber.length <= min_chamber_size && chamber[0].length <= min_chamber_size ){\r\n        return generatedWallsInOrder;\r\n    }\r\n\r\n    // Create the outer walls\r\n    if(generatedWallsInOrder.length === 0) {\r\n        for(var row = 0; row < chamber.length; row++){\r\n            for(var col = 0; col < chamber[0].length; col++){\r\n                if(row === 0 || col === 0 || row === chamber.length - 1 || col === chamber[0].length - 1 ){\r\n                    if(chamber[row][col].type === \"default\" || chamber[row][col].type === \"wallNode\") generatedWallsInOrder.push(chamber[row][col]);\r\n                }\r\n            }\r\n        }\r\n        chamber = chamber.slice(1, chamber.length - 1);\r\n        for(var row = 0; row < chamber.length; row++){\r\n            chamber[row] = chamber[row].slice(1, chamber[row].length - 1);\r\n        }\r\n    }\r\n\r\n    // Divide chamber horizonally if the chamber is more tall than wide\r\n    if(chamber.length > chamber[0].length){\r\n        // Select a random row within the chamber to draw walls. \r\n        // Leave a one row space to prevent a double wall\r\n        var wallLineRow = randomInteger(1, chamber.length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        var entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber[0].length - 1;\r\n        // Add walls along that row\r\n        for(var col = 0; col < chamber[wallLineRow].length; col++){\r\n            if(col !== entranceIdx && chamber[wallLineRow][col] && chamber[wallLineRow][col].type !== \"startNode\" && chamber[wallLineRow][col].type !== \"finishNode\") generatedWallsInOrder.push(chamber[wallLineRow][col]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newTopChamber = [];\r\n        var newBottomChamber = [];\r\n        for(var row = 0; row < chamber.length; row++){\r\n            const currentRowTopChamber = [];\r\n            const currentRowBottomChamber = [];\r\n            for(var col = 0; col < chamber[0].length; col++){\r\n                if(row < wallLineRow) currentRowTopChamber.push(chamber[row][col]);\r\n                if(row > wallLineRow) currentRowBottomChamber.push(chamber[row][col]); \r\n            }\r\n            if(currentRowTopChamber.length !== 0) newTopChamber.push(currentRowTopChamber);\r\n            if(currentRowBottomChamber.length !== 0) newBottomChamber.push(currentRowBottomChamber);\r\n            \r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newTopChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newBottomChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n\r\n    } else {\r\n        // Select a random col within the chamber to draw walls. \r\n        // Leave a one col space to prevent a double wall\r\n        var wallLineCol = randomInteger(1, chamber[0].length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        var entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber.length - 1;\r\n        // Add walls along that col\r\n        for(var row = 0; row < chamber.length; row++){\r\n            if(row !== entranceIdx && chamber[row][wallLineCol] && chamber[row][wallLineCol].type !== \"startNode\" && chamber[row][wallLineCol].type !== \"finishNode\") generatedWallsInOrder.push(chamber[row][wallLineCol]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newLeftChamber = [];\r\n        var newRightChamber = [];\r\n        for(var row = 0; row < chamber.length; row++){\r\n            const currentRowLeftChamber = [];\r\n            const currentRowRightChamber = [];\r\n            for(var col = 0; col < chamber[0].length; col++){\r\n                if(col < wallLineCol) currentRowLeftChamber.push(chamber[row][col]);\r\n                if(col > wallLineCol) currentRowRightChamber.push(chamber[row][col]);\r\n            }\r\n            newLeftChamber.push(currentRowLeftChamber);\r\n            newRightChamber.push(currentRowRightChamber);\r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newLeftChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newRightChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n    }\r\n\r\n    return generatedWallsInOrder;\r\n}\r\n\r\nexport function visualizeRecursiveDivision(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    resetGrid(algoVisualizer, ()=>{\r\n        var startTime = new Date().getTime();\r\n        // Get the generated walls in order\r\n        const generatedWallsInOrder = computeRecursiveDivision(grid, startNodeCoords, finishNodeCoords, []);\r\n        var runTimeSeconds = new Date().getTime() - startTime;\r\n        algoVisualizer.setState({ runTimeSeconds, lastAlgoRunString: \"Recursive Division\" });\r\n        animateGeneration(algoVisualizer, generatedWallsInOrder, setWalls);\r\n    });\r\n}\r\n\r\nfunction setWalls(algoVisualizer, grid, walls){\r\n    for(var node of walls){\r\n        const newNode = {\r\n            ...node,\r\n            type: \"wallNode\"\r\n            };\r\n        grid[node.row][node.col] = newNode;\r\n    }\r\n    algoVisualizer.setState({ grid, numWalls: walls.length });\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport Stats from './Stats/Stats';\r\nimport Legend from './Legend/Legend';\r\n\r\nimport {visualizeDijkstra} from '../Algorithms/Search/dijkstra';\r\nimport {visualizeAStar} from '../Algorithms/Search/aStar';\r\nimport {visualizeDFS} from '../Algorithms/Search/dfs';\r\nimport {visualizeBFS} from '../Algorithms/Search/bfs';\r\nimport {getInitialGrid, resetGrid, clearPath, createNode, randomInteger, getRandomEmptyNodeCoords} from '../Algorithms/helpers';\r\nimport './AlgoVisualizer.css';  \r\nimport { visualizeRecursiveDivision } from '../Algorithms/Generator/recursiveDivision';\r\n\r\nexport default class AlgoVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            startNodeCoords: [5, 10],\r\n            finishNodeCoords: [7, 40],\r\n            running: false,\r\n            dragging: \"\",\r\n            isPathDrawn: false,\r\n            lastAlgoRunString: \"\",\r\n            runTimeSeconds: 0,\r\n            numNodesInPath: 0,\r\n            numVisitedNodes: 0,\r\n            numWalls: 0\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = getInitialGrid(this);\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        var type = this.state.grid[row][col].type;\r\n        var numWalls = this.state.numWalls;\r\n        if(!this.state.running){\r\n            if(type === \"startNode\") {\r\n                this.setState({ dragging: \"startNode\" });\r\n            } else if(type === \"finishNode\"){\r\n                this.setState({ dragging: \"finishNode\" });\r\n            } else {\r\n                numWalls = type === \"wallNode\" ? numWalls - 1 : numWalls + 1;\r\n                const newGrid = getWallUpdatedGrid(this.state.grid, row, col);\r\n                this.setState({ grid: newGrid, dragging: \"wallNode\", numWalls });\r\n            }\r\n        }\r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        const enteredNodeType = this.state.grid[row][col].type;\r\n        var newGrid = this.state.grid;\r\n        var numWalls = this.state.numWalls;\r\n\r\n        if(!this.state.dragging === \"\") return;\r\n        if(!this.state.running){\r\n            if(this.state.dragging === \"startNode\"){\r\n                if(enteredNodeType === \"finishNode\"){\r\n                    const randomEmptyNodeCoords = getRandomEmptyNodeCoords(this);\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"finishNode\");\r\n                    this.setState({ finishNodeCoords: randomEmptyNodeCoords });\r\n                } else if(enteredNodeType === \"wallNode\") {\r\n                    numWalls -= 1;\r\n                }\r\n                newGrid = getNodeUpdatedGrid(newGrid, row, col, \"startNode\");\r\n                this.setState({ grid: newGrid, numWalls });\r\n            } else if(this.state.dragging === \"finishNode\") {\r\n                if(enteredNodeType === \"startNode\"){\r\n                    const randomEmptyNodeCoords = getRandomEmptyNodeCoords(this);\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"startNode\");\r\n                    this.setState({ startNodeCoords: randomEmptyNodeCoords });\r\n                } else if(enteredNodeType === \"wallNode\") {\r\n                    numWalls -= 1;\r\n                }\r\n                newGrid = getNodeUpdatedGrid(newGrid, row, col, \"finishNode\");\r\n                this.setState({ grid: newGrid, numWalls });\r\n\r\n            } else if(this.state.dragging === \"wallNode\") {\r\n                numWalls = enteredNodeType === \"wallNode\" ? numWalls - 1 : numWalls + 1;\r\n                newGrid = getWallUpdatedGrid(newGrid, row, col);\r\n                this.setState({ grid: newGrid, numWalls });\r\n            }\r\n        }\r\n    }\r\n    \r\n    handleMouseLeave(row, col){\r\n        if(!this.state.running){\r\n            if(this.state.dragging === \"startNode\" || this.state.dragging === \"finishNode\"){\r\n                if(this.state.isPathDrawn){\r\n                    clearPath(this);\r\n                }\r\n                const newGrid = getNodeUpdatedGrid(this.state.grid, row, col, \"default\");\r\n                this.setState({ grid: newGrid });\r\n            }\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        if(!this.state.running){\r\n            if(this.state.dragging === \"startNode\"){\r\n                const newGrid = getNodeUpdatedGrid(this.state.grid, row, col, \"startNode\");\r\n                this.setState({ grid: newGrid, dragging: \"\", startNodeCoords: [row, col] });\r\n            } else if(this.state.dragging === \"finishNode\") {\r\n                const newGrid = getNodeUpdatedGrid(this.state.grid, row, col, \"finishNode\");\r\n                this.setState({ grid: newGrid, dragging: \"\", finishNodeCoords: [row, col] });\r\n                \r\n            }\r\n        }\r\n        this.setState({ dragging: \"\" });\r\n    }\r\n\r\n    randomizeStartFinishNodes() {\r\n        var {grid, startNodeCoords, finishNodeCoords } = this.state;\r\n        \r\n        grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"default\", Infinity);\r\n        grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"default\", Infinity);\r\n        \r\n        var emptyNodes = [];\r\n        // Get all empty nodes\r\n        for(var row of grid){\r\n            var newRow = row.filter(node => node.type === \"default\");\r\n            if(newRow.length > 0) emptyNodes.push(newRow);\r\n        }\r\n\r\n        if(emptyNodes.length > 0) {\r\n            var startNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var startNode = emptyNodes[startNodeRow][randomInteger(0, emptyNodes[startNodeRow].length - 1)];\r\n            var finishNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var finishNode = emptyNodes[finishNodeRow][randomInteger(0, emptyNodes[finishNodeRow].length - 1)];\r\n    \r\n            startNodeCoords = [startNode.row, startNode.col];\r\n            finishNodeCoords = [finishNode.row, finishNode.col];\r\n            \r\n            grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"startNode\", 0);\r\n            grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"finishNode\", Infinity);\r\n            \r\n            this.setState({ grid, startNodeCoords, finishNodeCoords });\r\n        }\r\n    }\r\n\r\n    render() {\r\n        const {grid, startNodeCoords, finishNodeCoords, runTimeSeconds, numNodesInPath, numVisitedNodes, numWalls, lastAlgoRunString} = this.state;\r\n\r\n        return (\r\n            <div>\r\n                <div className='menu'>\r\n                    <h1 className='title'>Pathfinding Visualizer</h1>\r\n                    <div className='menu-group-container'>\r\n                        <div className='menu-group'>\r\n                            <h2>Pathfinding</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeDijkstra(this, grid, startNodeCoords, finishNodeCoords)}>Dijkstra's Algorithm</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeAStar(this, grid, startNodeCoords, finishNodeCoords)}>A*</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeDFS(this, grid, startNodeCoords, finishNodeCoords)}>DFS</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeBFS(this, grid, startNodeCoords, finishNodeCoords)}>BFS</button>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Generators</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeRecursiveDivision(this, grid, startNodeCoords, finishNodeCoords)}>Recursive Division</button>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Board Options</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> resetGrid(this)}>Clear Walls</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this)}>Clear Path</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this, this.randomizeStartFinishNodes)}>Randomize Start and End Nodes</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"grid-container\">\r\n                    <Legend></Legend>\r\n                    <Stats\r\n                        runTimeSeconds={runTimeSeconds}\r\n                        numNodesInPath={numNodesInPath}\r\n                        numVisitedNodes={numVisitedNodes}\r\n                        numWalls={numWalls}\r\n                        lastAlgoRunString={lastAlgoRunString}\r\n                        ></Stats>\r\n                    <div className=\"grid\">\r\n                        {grid.map((row, rowIdx) => {\r\n                            return (\r\n                                <div key={rowIdx}>\r\n                                    {row.map((node, nodeIdx) => {\r\n                                        const { row, col, type, distance } = node;\r\n                                        return (\r\n                                            <Node\r\n                                                key={nodeIdx}\r\n                                                className='node'\r\n                                                row={row}\r\n                                                col={col}\r\n                                                type={type}\r\n                                                distance={distance}\r\n                                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                                onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                                                onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\r\n                                            ></Node>);\r\n                                    })}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                </div>\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction getWallUpdatedGrid(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        type: node.type === \"wallNode\" ? \"default\" : node.type === \"default\" ? \"wallNode\" : node.type\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\nfunction getNodeUpdatedGrid(grid, row, col, type) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        type\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport AlgoVisuaizer from './AlgoVisualizer/AlgoVisualizer';\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <AlgoVisuaizer></AlgoVisuaizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}