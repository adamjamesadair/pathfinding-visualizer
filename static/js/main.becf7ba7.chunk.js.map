{"version":3,"sources":["AlgoVisualizer/Node/Node.jsx","AlgoVisualizer/Stats/Stats.jsx","AlgoVisualizer/Legend/Legend.jsx","Algorithms/helpers.js","Algorithms/Search/dijkstra.js","Algorithms/Search/aStar.js","Algorithms/Search/dfs.js","Algorithms/Search/bfs.js","Algorithms/Generator/recursiveDivision.js","AlgoVisualizer/AlgoVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","props","state","this","row","col","type","text","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","typeClass","id","className","Component","Stats","lastAlgoRunString","runTimeSeconds","numNodesInPath","numVisitedNodes","numWalls","Legend","animateAlgorithm","algoVisualizer","visitedNodesInOrderList","nodesInShortestPathOrderList","length","i","Set","size","setTimeout","nodesInShortestPathOrder","delay","node","nodeElement","document","getElementById","replace","setState","running","animateShortestPath","oldClasses","getAllNodes","grid","nodes","push","getUnvisitedNeighbors","neighbors","filter","neighbor","isVisited","getNodesInShortestPathOrder","finishNode","currentNode","unshift","previousNode","clearPath","callback","distance","Infinity","createNode","isPathDrawn","heuristic","randomInteger","min","max","Math","floor","random","resetGrid","startNodeCoords","finishNodeCoords","getInitialGrid","checkpointNodes","currentRow","startRow","startCol","finishRow","finishCol","getEuclideanDistance","x1","y1","x2","y2","a","b","sqrt","visualizAlgorithm","computeAlgorithm","startTime","destinationNodeInfo","gridCopy","startNode","originalStartNodeCoords","visitedNodesInOrder","sort","nodeA","nodeB","checkpointNodeInfo","getDestinationNodeInfo","coords","Date","getTime","_","cloneDeep","isPathPossible","flat","visitedNodesToAnimate","pathNodesToAnimate","computeDijkstra","visitedNodes","unvisitedNodes","closestNode","shift","updateUnvisitedNeighbors","unvisitedNeighbors","computeAStar","abs","getGridWithHeuristics","updateneighbors","getNeighbors","computeDFS","unvisitedNeighbor","newVisitedNodes","computeBFS","queue","path","includes","visualizeRecursiveDivision","generatedWallsInOrder","computeRecursiveDivision","chamber","wallLineRow","wallLineCol","entranceIdx","slice","newTopChamber","newBottomChamber","currentRowTopChamber","currentRowBottomChamber","newLeftChamber","newRightChamber","currentRowLeftChamber","currentRowRightChamber","animateGeneration","setWalls","walls","newNode","AlgoVisualizer","draggingCheckpointNodeInfo","dragging","newGrid","getWallUpdatedGrid","forEach","enteredNodeType","getNodeUpdatedGrid","randomEmptyNodeCoords","emptyNodes","newRow","nodeRow","getRandomEmptyNodeCoords","getEmptyNodes","startNodeRow","finishNodeRow","checkpointNodeRow","checkpointNode","checkpointNodeCoords","reverse","disabled","onClick","addCheckpointNode","randomizeStartFinishNodes","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","handleMouseLeave","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.becf7ba7.chunk.js","sourcesContent":["import React, {Component} from 'react';\r\n\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            type,\r\n            text,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave\r\n        } = this.props;\r\n\r\n        const typeClass = type === \"finishNode\"\r\n            ? 'node-finish'\r\n            : type === \"startNode\"\r\n            ? 'node-start'\r\n            : type === \"checkpointNode\"\r\n            ? 'node-checkpoint'\r\n            : type === \"wallNode\"\r\n            ? 'node-wall'\r\n            : '';\r\n\r\n        return (\r\n            <div \r\n                id={`node-${row}-${col}`}\r\n                className = {`node ${typeClass}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseLeave={() => onMouseLeave(row, col)}\r\n                onMouseUp={() => onMouseUp(row, col)}><div className='node-center'>{text}</div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\n\r\nimport './Stats.css';\r\n\r\nexport default class Stats extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {\r\n            lastAlgoRunString,\r\n            runTimeSeconds,\r\n            numNodesInPath,\r\n            numVisitedNodes,\r\n            numWalls\r\n        } = this.props;\r\n\r\n        return (\r\n            <div id='stats-component' className=\"stats-component\">\r\n                        <p className=\"stat\"><b>Last Algorithm Run: </b> {lastAlgoRunString}</p>\r\n                        <p className=\"stat\"><b>Calculation Time: </b> {runTimeSeconds}ms</p>\r\n                        <p className=\"stat\"><b>Nodes in Path:</b> {numNodesInPath}</p>\r\n                        <p className=\"stat\"><b>Nodes Visited:</b> {numVisitedNodes}</p>\r\n                        <p className=\"stat\"><b>Walls:</b> {numWalls}</p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import React, {Component} from 'react';\r\nimport './Legend.css';\r\nimport '../Node/Node.css';\r\n\r\nexport default class Legend extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div id='legend-component' className=\"legend-component\">\r\n                        <div className='node node-start'></div><p className=\"legend-item\"><b> Start</b></p>\r\n                        <div className='node node-finish'></div><p className=\"legend-item\"><b> Finish</b></p>\r\n                        <div className='node node-wall'></div><p className=\"legend-item\"><b> Wall</b></p>\r\n                        <div className='node node-visited node-legend'></div><p className=\"legend-item\"><b> Visited</b></p>\r\n                        <div className='node node-shortest-path node-legend'></div><p className=\"legend-item\"><b> Path</b></p>\r\n                        <div className='node node-current node-legend'></div><p className=\"legend-item\"><b> Current</b></p>\r\n                        <div className='node node-legend'></div><p className=\"legend-item\"><b> Unvisited</b></p>\r\n                        <div className='node node-checkpoint node-legend'></div><p className=\"legend-item\"><b> Checkpoint</b></p>\r\n                        <div className='node node-checkpoint node-current node-legend'></div><p className=\"legend-item\"><b> Visited Checkpoint</b></p>\r\n                    </div>\r\n        );\r\n    }\r\n}\r\n\r\n\r\n","import _ from \"lodash\";\r\n\r\nexport function animateAlgorithm(algoVisualizer, visitedNodesInOrderList, nodesInShortestPathOrderList) {\r\n    const delay = 10;\r\n    const shortestPathDelay = 25;\r\n    var numVisitedNodes = 0;\r\n    var numNodesInPath = 0;\r\n\r\n    numVisitedNodes += visitedNodesInOrderList.length;\r\n    for (let i = 0; i < visitedNodesInOrderList.length; i++) {\r\n        if (i === visitedNodesInOrderList.length - 1) {\r\n            numNodesInPath += new Set(nodesInShortestPathOrderList).size;\r\n            // Animate the shortest path\r\n            setTimeout(() => {\r\n                animateShortestPath(algoVisualizer, nodesInShortestPathOrderList, shortestPathDelay);\r\n            }, delay * i);\r\n        }\r\n        \r\n        setTimeout(() => {\r\n            const node = visitedNodesInOrderList[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the visted nodes\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-visited';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    algoVisualizer.setState({ numVisitedNodes, numNodesInPath });\r\n}\r\n\r\nfunction animateShortestPath(algoVisualizer, nodesInShortestPathOrder, delay=25) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = nodesInShortestPathOrder[i];\r\n            // Redraw element to restart animation on nodes with class node-shortest-path\r\n            var nodeElement = document.getElementById(`node-${node.row}-${node.col}`);\r\n            nodeElement.className = nodeElement.className.replace(\" node-shortest-path\", \"\");\r\n            setTimeout(()=>{nodeElement.className = nodeElement.className + ' node-shortest-path';}, 10);\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{algoVisualizer.setState({running: false});}, delay * nodesInShortestPathOrder.length);\r\n}\r\n\r\nexport function animateGeneration(algoVisualizer, generatedWallsInOrder, callback=null) {\r\n    const { grid } = algoVisualizer.state;\r\n    const delay = 10;\r\n    for (let i = 0; i < generatedWallsInOrder.length; i++) {\r\n        setTimeout(() => {\r\n            const node = generatedWallsInOrder[i];\r\n            var oldClasses = document.getElementById(`node-${node.row}-${node.col}`).className\r\n            // Animate the current node\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-current';\r\n            // Animate the walls\r\n            setTimeout(()=>{\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = oldClasses + ' node-wall';\r\n            }, delay);\r\n        }, delay * i);\r\n    }\r\n    setTimeout(()=>{\r\n        algoVisualizer.setState({running: false});\r\n        if(callback) callback(algoVisualizer, grid, generatedWallsInOrder);\r\n    }, delay * generatedWallsInOrder.length);\r\n}\r\n\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nexport function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\nexport function getNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {row, col} = node;\r\n\r\n    if(row > 0) neighbors.push(grid[row-1][col]);\r\n    if(row + 1 < grid.length) neighbors.push(grid[row + 1][col]);\r\n    if(col > 0) neighbors.push(grid[row][col-1]);\r\n    if(col + 1 < grid[0].length) neighbors.push(grid[row][col + 1]);\r\n\r\n    return neighbors;\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    var currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n        nodesInShortestPathOrder.unshift(currentNode);\r\n        currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n}\r\n\r\nexport function sortNodesByDistance(nodes) {\r\n    nodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nexport function sortNodesByDistanceAndHeuristic(nodes){\r\n    nodes.sort(function (nodeA, nodeB) {\r\n        // Sort on distance\r\n        if(nodeA.distance > nodeB.distance) {\r\n            return 1;\r\n        } else if (nodeA.distance < nodeB.distance) {\r\n            return -1;\r\n        } else {\r\n            // If the distances are the same,\r\n            // sort on distance - heuristic\r\n            if(nodeA.heuristic > nodeB.heuristic) {\r\n                return 1;\r\n            } else if (nodeA.heuristic < nodeB.heuristic) {\r\n                return -1;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function clearPath(algoVisualizer, callback=null) {\r\n    var { grid } = algoVisualizer.state;\r\n    \r\n    for(const row of grid) {\r\n        for(var node of row){\r\n            // update node values\r\n            var distance = node.type === \"startNode\" ? 0 : Infinity; \r\n            grid[node.row][node.col] = createNode(node.row, node.col, node.type, distance, node.text);\r\n            // update css class\r\n            if(node.type === \"default\"){\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n            } else if(node.type === \"checkpointNode\") {\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-checkpoint';\r\n            }\r\n        }\r\n    }\r\n    algoVisualizer.setState({ grid, isPathDrawn: false, numNodesInPath: 0, numVisitedNodes: 0 }, callback);\r\n}\r\n\r\nexport function createNode(row, col, type, distance, text=\"\") {\r\n    return {\r\n        row,\r\n        col,\r\n        type,\r\n        text,\r\n        distance,\r\n        heuristic: 0,\r\n        isVisited: false,\r\n        previousNode: null\r\n    }\r\n}\r\n\r\nexport function randomInteger(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1)) + min;\r\n}\r\n\r\nexport function randomEvenInteger(min, max) {\r\n    var temp =(Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2;\r\n    return temp;\r\n}\r\n\r\nexport function randomOddInteger(min, max) {\r\n    var temp = (Math.floor(Math.random() * (Math.floor(max/2) - min + 1)) + min) * 2 + 1;\r\n    return temp;\r\n}\r\n\r\nexport function resetGrid(algoVisualizer, callback) {\r\n    var { grid, startNodeCoords, finishNodeCoords } = algoVisualizer.state;\r\n\r\n    // reset node classnames\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node';\r\n        }\r\n    }\r\n\r\n    // set start and finish node classnames\r\n    document.getElementById(`node-${startNodeCoords[0]}-${startNodeCoords[1]}`).className = 'node node-start';\r\n    document.getElementById(`node-${finishNodeCoords[0]}-${finishNodeCoords[1]}`).className = 'node node-finish';\r\n    grid = getInitialGrid(algoVisualizer);\r\n    algoVisualizer.setState({ grid, numWalls: 0, numNodesInPath: 0, numVisitedNodes: 0, checkpointNodes: [] }, callback);\r\n}\r\n\r\nexport function getInitialGrid(algoVisualizer){\r\n    // Generate the empty grid\r\n    const grid = [];\r\n    const nodesPerRow = 20;\r\n    const nodesPerCol = 50;\r\n    for (let row = 0; row < nodesPerRow; row++) {\r\n        const currentRow = [];\r\n        for (let col = 0; col < nodesPerCol; col++) {\r\n            currentRow.push(createNode(row, col, \"default\", Infinity));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n\r\n    // Set the start and finish nodes\r\n    const [startRow, startCol] = algoVisualizer.state.startNodeCoords;\r\n    const [finishRow, finishCol] = algoVisualizer.state.finishNodeCoords;\r\n    grid[startRow][startCol] = createNode(startRow, startCol, \"startNode\", 0);\r\n    grid[finishRow][finishCol] = createNode(finishRow, finishCol, \"finishNode\", Infinity);\r\n    return grid;\r\n};\r\n\r\nexport function getEuclideanDistance(x1, y1, x2, y2){\r\n    var a = x1 - x2;\r\n    var b = y1 - y2;\r\n    return Math.sqrt( a*a + b*b );\r\n}\r\n\r\nexport function getRandomEmptyNodeCoords(algoVisualizer){\r\n    var { grid } = algoVisualizer.state;\r\n    var emptyNodes = [];\r\n    // Get all empty nodes\r\n    for(var row of grid){\r\n        var newRow = row.filter(node => node.type === \"default\");\r\n        if(newRow.length > 0) emptyNodes.push(newRow);\r\n    }\r\n\r\n    if(emptyNodes.length > 0) {\r\n        var nodeRow = randomInteger(0, emptyNodes.length - 1);\r\n        var node = emptyNodes[nodeRow][randomInteger(0, emptyNodes[nodeRow].length - 1)];\r\n        return [node.row, node.col];\r\n    }\r\n}\r\n\r\nexport function visualizAlgorithm(computeAlgorithm, lastAlgoRunString, algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    var startTime, runTimeSeconds, destinationNodeInfo, gridCopy, startNode, finishNode;\r\n    var originalStartNodeCoords = algoVisualizer.state.startNodeCoords;\r\n    var visitedNodesInOrder = [];\r\n    var nodesInShortestPathOrder = [];\r\n    var checkpointNodes = algoVisualizer.state.checkpointNodes;\r\n    checkpointNodes.sort((nodeA, nodeB) => nodeA.id - nodeB.id);\r\n\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    // Reset the checkpoint nodes\r\n    for(var checkpointNodeInfo of checkpointNodes) {\r\n        checkpointNodeInfo.isVisited = false;\r\n        checkpointNodeInfo.distance = Infinity;\r\n    }\r\n\r\n    while(algoVisualizer.getDestinationNodeInfo().coords !== finishNodeCoords) {\r\n        destinationNodeInfo = algoVisualizer.getDestinationNodeInfo();\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        gridCopy[startNodeCoords[0]][startNodeCoords[1]].distance = 0;\r\n        if(lastAlgoRunString === \"DFS\") {\r\n            startNode = gridCopy[startNodeCoords[0]][startNodeCoords[1]];\r\n            finishNode = gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]];\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNode, finishNode, [])[1]);\r\n        } else {\r\n            visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNodeCoords, destinationNodeInfo.coords));\r\n        }\r\n        nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]]));\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        startNodeCoords = destinationNodeInfo.coords;\r\n        destinationNodeInfo.isVisited = true;\r\n        for(let checkpointNodeInfo of checkpointNodes) {\r\n            if(checkpointNodeInfo.id === destinationNodeInfo.id - 1) checkpointNodeInfo = destinationNodeInfo;\r\n        }\r\n    }\r\n    \r\n    startTime = new Date().getTime();\r\n    gridCopy = _.cloneDeep(grid);\r\n    gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n    gridCopy[startNodeCoords[0]][startNodeCoords[1]].distance = 0;\r\n    if(lastAlgoRunString === \"DFS\") {\r\n        startNode = gridCopy[startNodeCoords[0]][startNodeCoords[1]];\r\n        finishNode = gridCopy[finishNodeCoords[0]][finishNodeCoords[1]];\r\n        visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNode, finishNode, [])[1]);\r\n    } else {\r\n        visitedNodesInOrder.push(computeAlgorithm(gridCopy, startNodeCoords, finishNodeCoords));\r\n    }\r\n    nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[finishNodeCoords[0]][finishNodeCoords[1]]));\r\n    runTimeSeconds = new Date().getTime() - startTime;\r\n\r\n    var isPathPossible = true;\r\n    for(var nodesInShortestPath of nodesInShortestPathOrder) {\r\n        if(nodesInShortestPath.length <= 1 ) {\r\n            isPathPossible = false;\r\n        }\r\n    }\r\n\r\n    if(isPathPossible) {\r\n        animateAlgorithm(algoVisualizer, visitedNodesInOrder.flat(), nodesInShortestPathOrder.flat());\r\n    } else {\r\n        animateAlgorithm(algoVisualizer, visitedNodesInOrder.flat(), []);\r\n    }\r\n    algoVisualizer.setState({ visitedNodesToAnimate: visitedNodesInOrder, pathNodesToAnimate: nodesInShortestPathOrder, checkpointNodes, isPathDrawn: true, runTimeSeconds, lastAlgoRunString});\r\n}","import { animateAlgorithm, sortNodesByDistance, getAllNodes, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeDijkstra(grid, startNodeCoords, finishNodeCoords) {\r\n  const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n  const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n  startNode.distance = 0;\r\n  var visitedNodes = [];\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while(unvisitedNodes.length){\r\n      // Sort the nodes by distance\r\n      sortNodesByDistance(unvisitedNodes);\r\n      // Get the closest unvisited node\r\n      var closestNode = unvisitedNodes.shift();\r\n      // unvisitedNodes.unshift();\r\n      // Skip if the closest node is a wall\r\n      if(closestNode.type === \"wallNode\") continue;\r\n      // Return if there are no possible routes\r\n      if (closestNode.distance === Infinity) return visitedNodes;\r\n      closestNode.isVisited = true;\r\n      visitedNodes.push(closestNode);\r\n\r\n      // Check if the current node is the finish node\r\n      if(closestNode === finishNode) return visitedNodes;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nexport function visualizeDijkstra(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n  algoVisualizer.setState({running: true});\r\n  clearPath(algoVisualizer);\r\n  var startTime = new Date().getTime();\r\n  const visitedNodesInOrder = computeDijkstra(grid, startNodeCoords, finishNodeCoords);\r\n  const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n  var runTimeSeconds = new Date().getTime() - startTime;\r\n  animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n  algoVisualizer.setState({ isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"Dijkstra\" });\r\n}\r\n\r\n\r\n","import { animateAlgorithm, sortNodesByDistanceAndHeuristic, getAllNodes, getNeighbors, getNodesInShortestPathOrder, clearPath, getEuclideanDistance } from '../helpers.js';\r\nimport _ from \"lodash\";\r\n\r\nexport function computeAStar(grid, startNodeCoords, finishNodeCoords) {\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    grid = getGridWithHeuristics(grid, finishNode, \"manhattan\");\r\n    startNode.distance = 0;\r\n    var visitedNodes = [];\r\n    const unvisitedNodes = getAllNodes(grid);\r\n\r\n    while(unvisitedNodes.length){\r\n        // Sort the nodes by distance\r\n        sortNodesByDistanceAndHeuristic(unvisitedNodes);\r\n        // Get the closest unvisited node\r\n        var closestNode = unvisitedNodes.shift();\r\n        // Skip if the closest node is a wall\r\n        if(closestNode.type === \"wallNode\") continue;\r\n        // Return if there are no possible routes\r\n        if (closestNode.distance === Infinity) return visitedNodes;\r\n        closestNode.isVisited = true;\r\n        visitedNodes.push(closestNode);\r\n\r\n        // Check if the current node is the finish node\r\n        if(closestNode === finishNode) return visitedNodes;\r\n        updateneighbors(closestNode, grid);\r\n    }\r\n}\r\n\r\nexport function visualizeAStar(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    var startTime, runTimeSeconds, destinationNodeInfo, gridCopy;\r\n    var { originalStartNodeCoords, checkpointNodes } = algoVisualizer.state;\r\n    var visitedNodesInOrder = [];\r\n    var nodesInShortestPathOrder = [];\r\n\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n\r\n    while(algoVisualizer.getDestinationNodeInfo().coords !== finishNodeCoords) {\r\n        destinationNodeInfo = algoVisualizer.getDestinationNodeInfo();\r\n        startTime = new Date().getTime();\r\n        gridCopy = _.cloneDeep(grid);\r\n        gridCopy[originalStartNodeCoords[0]][originalStartNodeCoords[1]].distance = Infinity;\r\n        visitedNodesInOrder.push(computeAStar(gridCopy, startNodeCoords, destinationNodeInfo.coords));\r\n        nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[destinationNodeInfo.coords[0]][destinationNodeInfo.coords[1]]));\r\n        runTimeSeconds = new Date().getTime() - startTime;\r\n        startNodeCoords = destinationNodeInfo.coords;\r\n        destinationNodeInfo.isVisited = true;\r\n        checkpointNodes[destinationNodeInfo.id - 1] = destinationNodeInfo;\r\n    }\r\n    \r\n    startTime = new Date().getTime();\r\n    gridCopy = _.cloneDeep(grid);\r\n    visitedNodesInOrder.push(computeAStar(gridCopy, startNodeCoords, finishNodeCoords));\r\n    nodesInShortestPathOrder.push(getNodesInShortestPathOrder(gridCopy[finishNodeCoords[0]][finishNodeCoords[1]]));\r\n    runTimeSeconds = new Date().getTime() - startTime;\r\n\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({visitedNodesToAnimate: visitedNodesInOrder, pathNodesToAnimate: nodesInShortestPathOrder, checkpointNodes, isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"A*\"});\r\n}\r\n\r\nfunction updateneighbors(node, grid) {\r\n    const neighbors = getNeighbors(node, grid);\r\n    const weight = 1;\r\n    for (const neighbor of neighbors) {\r\n        if(neighbor.isVisited){\r\n            if(neighbor.distance - neighbor.heuristic < node.previousNode.distance - node.previousNode.heuristic){\r\n                node.previousNode = neighbor;\r\n            }\r\n        } else {\r\n            if(node.distance === 0){\r\n                neighbor.distance = weight + neighbor.heuristic; \r\n            } else {\r\n                neighbor.distance = node.distance - node.heuristic + weight + neighbor.heuristic;\r\n            }\r\n            neighbor.previousNode = node;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getGridWithHeuristics(grid, finishNode, heuristic=\"manhattan\"){\r\n    for (const row of grid) {\r\n        for (const node of row) {\r\n            if(heuristic === \"manhattan\"){\r\n                // Manhattan distance heuristic\r\n                node.heuristic = Math.abs(node.row - finishNode.row) + Math.abs(node.col - finishNode.col);\r\n            } else if(heuristic === \"euclidean\") {\r\n                // Euclidean distance \r\n                node.heuristic = getEuclideanDistance(node.row, node.col, finishNode.row, finishNode.col);\r\n            }\r\n        }\r\n    }\r\n    return grid;\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeDFS(grid, currentNode, finishNode, visitedNodes) {\r\n    visitedNodes.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) return [visitedNodes, visitedNodes];\r\n    for(let unvisitedNeighbor of getUnvisitedNeighbors(currentNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")) {\r\n        if(!unvisitedNeighbor.isVisited){\r\n            unvisitedNeighbor.previousNode = currentNode;\r\n            var newVisitedNodes = computeDFS(grid, unvisitedNeighbor, finishNode, visitedNodes)[0];\r\n            if(newVisitedNodes) return [newVisitedNodes, newVisitedNodes];\r\n        }\r\n    }\r\n    return [null, visitedNodes];\r\n}\r\n\r\nexport function visualizeDFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeDFS(grid, startNode, finishNode, [])[1];\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    if(visitedNodesInOrder) animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder); else algoVisualizer.setState({running: false});\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"DFS\"});\r\n}","import { animateAlgorithm, getUnvisitedNeighbors, getNodesInShortestPathOrder, clearPath } from '../helpers.js';\r\n\r\nexport function computeBFS(grid, startNodeCoords, finishNodeCoords) {\r\n    var startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    var finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var queue = [startNode];\r\n    var path = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    if(startNode === finishNode) return path;\r\n\r\n    while(queue){\r\n        startNode = queue.shift();\r\n\r\n        if(startNode){\r\n            for(var neighbor of getUnvisitedNeighbors(startNode, grid).filter(neighbor => neighbor.type !== \"wallNode\")){\r\n                if(!path.includes(neighbor)){\r\n                    neighbor.previousNode = startNode;\r\n                    neighbor.isVisited = true;\r\n                    path.push(neighbor);\r\n                    queue.push(neighbor);\r\n    \r\n                    if(neighbor === finishNode) return path;\r\n                }\r\n            }\r\n        } else {\r\n            return path;\r\n        }\r\n\r\n    }\r\n    return path;\r\n}\r\n\r\nexport function visualizeBFS(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true, isPathDrawn: true});\r\n    clearPath(algoVisualizer);\r\n    const startNode = grid[startNodeCoords[0]][startNodeCoords[1]];\r\n    const finishNode = grid[finishNodeCoords[0]][finishNodeCoords[1]];\r\n    var startTime = new Date().getTime();\r\n    const visitedNodesInOrder = computeBFS(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(grid[finishNodeCoords[0]][finishNodeCoords[1]]);\r\n    var runTimeSeconds = new Date().getTime() - startTime;\r\n    animateAlgorithm(algoVisualizer, visitedNodesInOrder, nodesInShortestPathOrder);\r\n    algoVisualizer.setState({isPathDrawn: true, runTimeSeconds, lastAlgoRunString: \"BFS\"});\r\n}","import {resetGrid, randomInteger, animateGeneration} from '../helpers';\r\n\r\nexport function computeRecursiveDivision(chamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder){\r\n    \r\n    const min_chamber_size = 2;\r\n    var wallLineRow, wallLineCol, entranceIdx;\r\n\r\n    // If minimum chamber size is reached, return the generated walls\r\n    if(chamber.length <= min_chamber_size && chamber[0].length <= min_chamber_size ){\r\n        return generatedWallsInOrder;\r\n    }\r\n\r\n    // Create the outer walls\r\n    if(generatedWallsInOrder.length === 0) {\r\n        for(let row = 0; row < chamber.length; row++){\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(row === 0 || col === 0 || row === chamber.length - 1 || col === chamber[0].length - 1 ){\r\n                    if(chamber[row][col].type !== \"startNode\" && chamber[row][col].type !== \"finishNode\") generatedWallsInOrder.push(chamber[row][col]);\r\n                }\r\n            }\r\n        }\r\n        chamber = chamber.slice(1, chamber.length - 1);\r\n        for(let row = 0; row < chamber.length; row++){\r\n            chamber[row] = chamber[row].slice(1, chamber[row].length - 1);\r\n        }\r\n    }\r\n\r\n    // Divide chamber horizonally if the chamber is more tall than wide\r\n    if(chamber.length > chamber[0].length){\r\n        // Select a random row within the chamber to draw walls. \r\n        // Leave a one row space to prevent a double wall\r\n        wallLineRow = randomInteger(1, chamber.length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber[0].length - 1;\r\n        // Add walls along that row\r\n        for(var col = 0; col < chamber[wallLineRow].length; col++){\r\n            if(col !== entranceIdx && chamber[wallLineRow][col] && chamber[wallLineRow][col].type !== \"startNode\" && chamber[wallLineRow][col].type !== \"finishNode\") generatedWallsInOrder.push(chamber[wallLineRow][col]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newTopChamber = [];\r\n        var newBottomChamber = [];\r\n        for(let row = 0; row < chamber.length; row++){\r\n            const currentRowTopChamber = [];\r\n            const currentRowBottomChamber = [];\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(row < wallLineRow) currentRowTopChamber.push(chamber[row][col]);\r\n                if(row > wallLineRow) currentRowBottomChamber.push(chamber[row][col]); \r\n            }\r\n            if(currentRowTopChamber.length !== 0) newTopChamber.push(currentRowTopChamber);\r\n            if(currentRowBottomChamber.length !== 0) newBottomChamber.push(currentRowBottomChamber);\r\n            \r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newTopChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newBottomChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n\r\n    } else {\r\n        // Select a random col within the chamber to draw walls. \r\n        // Leave a one col space to prevent a double wall\r\n        wallLineCol = randomInteger(1, chamber[0].length - 2);\r\n        // Leave leave a space at one random location along the wall line\r\n        entranceIdx = randomInteger(0, 1) === 0 ? 0 : chamber.length - 1;\r\n        // Add walls along that col\r\n        for(let row = 0; row < chamber.length; row++){\r\n            if(row !== entranceIdx && chamber[row][wallLineCol] && chamber[row][wallLineCol].type !== \"startNode\" && chamber[row][wallLineCol].type !== \"finishNode\") generatedWallsInOrder.push(chamber[row][wallLineCol]);\r\n        }\r\n\r\n        // Recursively repeat on subchambers until minimum size of chamber is reached\r\n        // Get the two new chambers\r\n        var newLeftChamber = [];\r\n        var newRightChamber = [];\r\n        for(let row = 0; row < chamber.length; row++){\r\n            const currentRowLeftChamber = [];\r\n            const currentRowRightChamber = [];\r\n            for(let col = 0; col < chamber[0].length; col++){\r\n                if(col < wallLineCol) currentRowLeftChamber.push(chamber[row][col]);\r\n                if(col > wallLineCol) currentRowRightChamber.push(chamber[row][col]);\r\n            }\r\n            newLeftChamber.push(currentRowLeftChamber);\r\n            newRightChamber.push(currentRowRightChamber);\r\n        }\r\n\r\n        generatedWallsInOrder = computeRecursiveDivision(newLeftChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n        generatedWallsInOrder = computeRecursiveDivision(newRightChamber, startNodeCoords, finishNodeCoords, generatedWallsInOrder);\r\n    }\r\n\r\n    return generatedWallsInOrder;\r\n}\r\n\r\nexport function visualizeRecursiveDivision(algoVisualizer, grid, startNodeCoords, finishNodeCoords) {\r\n    algoVisualizer.setState({running: true});\r\n    resetGrid(algoVisualizer, ()=>{\r\n        var startTime = new Date().getTime();\r\n        // Get the generated walls in order\r\n        const generatedWallsInOrder = computeRecursiveDivision(grid, startNodeCoords, finishNodeCoords, []);\r\n        var runTimeSeconds = new Date().getTime() - startTime;\r\n        algoVisualizer.setState({ runTimeSeconds, lastAlgoRunString: \"Recursive Division\" });\r\n        animateGeneration(algoVisualizer, generatedWallsInOrder, setWalls);\r\n    });\r\n}\r\n\r\nfunction setWalls(algoVisualizer, grid, walls){\r\n    for(var node of walls){\r\n        const newNode = {\r\n            ...node,\r\n            type: \"wallNode\"\r\n            };\r\n        grid[node.row][node.col] = newNode;\r\n    }\r\n    algoVisualizer.setState({ grid, numWalls: walls.length });\r\n}","import React, {Component} from 'react';\r\nimport Node from './Node/Node';\r\nimport Stats from './Stats/Stats';\r\nimport Legend from './Legend/Legend';\r\n\r\nimport {computeDijkstra} from '../Algorithms/Search/dijkstra';\r\nimport {computeAStar} from '../Algorithms/Search/aStar';\r\nimport {computeDFS} from '../Algorithms/Search/dfs';\r\nimport {computeBFS} from '../Algorithms/Search/bfs';\r\nimport {getInitialGrid, resetGrid, clearPath, createNode, randomInteger, getRandomEmptyNodeCoords, visualizAlgorithm} from '../Algorithms/helpers';\r\nimport './AlgoVisualizer.css';  \r\nimport { visualizeRecursiveDivision } from '../Algorithms/Generator/recursiveDivision';\r\n\r\nexport default class AlgoVisualizer extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            startNodeCoords: [5, 10],\r\n            finishNodeCoords: [7, 40],\r\n            checkpointNodes: [],\r\n            draggingCheckpointNodeInfo: {},\r\n            running: false,\r\n            dragging: \"\",\r\n            isPathDrawn: false,\r\n            lastAlgoRunString: \"\",\r\n            runTimeSeconds: 0,\r\n            numNodesInPath: 0,\r\n            numVisitedNodes: 0,\r\n            numWalls: 0\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = getInitialGrid(this);\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        var type = this.state.grid[row][col].type;\r\n        var { running, grid, numWalls, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n\r\n        if(running) return; \r\n\r\n        if(type === \"wallNode\" || type === \"default\") {\r\n            numWalls = type === \"wallNode\" ? numWalls - 1 : numWalls + 1;\r\n            const newGrid = getWallUpdatedGrid(grid, row, col);\r\n            this.setState({ grid: newGrid, dragging: type, numWalls });\r\n        } else if (type === \"checkpointNode\") {\r\n            // Keep track of which checkpoiontNode is being dragged\r\n            checkpointNodes.forEach(checkpointNodeInfo => {\r\n                if (checkpointNodeInfo.coords[0] === row && checkpointNodeInfo.coords[1] === col) {\r\n                    draggingCheckpointNodeInfo = checkpointNodeInfo;\r\n                }\r\n            });\r\n            this.setState({ dragging: type, draggingCheckpointNodeInfo });\r\n        } else {\r\n            this.setState({ dragging: type });\r\n        }\r\n        \r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        const enteredNodeType = this.state.grid[row][col].type;\r\n        var newGrid = this.state.grid;\r\n        var { running, dragging, numWalls, startNodeCoords, finishNodeCoords, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n\r\n        if(running || dragging === \"\") return;\r\n\r\n        if([\"startNode\", \"finishNode\", \"checkpointNode\"].includes(dragging)) {\r\n            newGrid = dragging === \"checkpointNode\" \r\n                ? getNodeUpdatedGrid(newGrid, row, col, dragging, draggingCheckpointNodeInfo.id)\r\n                : getNodeUpdatedGrid(newGrid, row, col, dragging);\r\n\r\n            if(enteredNodeType === \"wallNode\") {\r\n                numWalls -= 1;\r\n            } else {\r\n                const randomEmptyNodeCoords = getRandomEmptyNodeCoords(this);\r\n                if(enteredNodeType === \"finishNode\") {\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"finishNode\");\r\n                    finishNodeCoords = randomEmptyNodeCoords;\r\n                } else if(enteredNodeType === \"startNode\") {\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"startNode\");\r\n                    startNodeCoords = randomEmptyNodeCoords;\r\n                } else if(enteredNodeType === \"checkpointNode\") {\r\n                    newGrid = getNodeUpdatedGrid(newGrid, randomEmptyNodeCoords[0], randomEmptyNodeCoords[1], \"checkpointNode\", draggingCheckpointNodeInfo.text);\r\n                    // Update checkpointNode state\r\n                    draggingCheckpointNodeInfo.coords = [row, col];\r\n                    checkpointNodes.forEach(checkpointNodeInfo => {\r\n                        if(checkpointNodeInfo.id === draggingCheckpointNodeInfo.id) checkpointNodeInfo = draggingCheckpointNodeInfo;\r\n                    });\r\n                }\r\n            }\r\n        } else if(dragging === \"default\") {\r\n            numWalls = enteredNodeType === \"wallNode\" ? numWalls - 1 : numWalls + 1;\r\n            newGrid = getWallUpdatedGrid(newGrid, row, col);\r\n        }\r\n        this.setState({ grid: newGrid, numWalls, startNodeCoords, finishNodeCoords, checkpointNodes, draggingCheckpointNodeInfo });\r\n    }\r\n    \r\n    handleMouseLeave(row, col){\r\n        if(this.state.running) return;\r\n        if([\"startNode\", \"finishNode\", \"checkpointNode\"].includes(this.state.dragging)){\r\n            if(this.state.isPathDrawn) clearPath(this);\r\n            this.setState({ grid: getNodeUpdatedGrid(this.state.grid, row, col, \"default\") });\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row, col) {\r\n        var { running, grid, dragging, checkpointNodes, draggingCheckpointNodeInfo } = this.state;\r\n        if(running) return;\r\n        if(dragging === \"startNode\"){\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"startNode\");\r\n            this.setState({ grid: newGrid, dragging: \"\", startNodeCoords: [row, col] });\r\n        } else if(dragging === \"finishNode\") {\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"finishNode\");\r\n            this.setState({ grid: newGrid, dragging: \"\", finishNodeCoords: [row, col] });\r\n        } else if(dragging === \"checkpointNode\") {\r\n            const newGrid = getNodeUpdatedGrid(grid, row, col, \"checkpointNode\", draggingCheckpointNodeInfo.id);\r\n            checkpointNodes.forEach(checkpointNodeInfo => {\r\n                if(checkpointNodeInfo.id === draggingCheckpointNodeInfo.id) checkpointNodeInfo.coords = [row, col];\r\n            });\r\n            this.setState({ grid: newGrid, dragging: \"\", checkpointNodes });\r\n        }\r\n        this.setState({ dragging: \"\" });\r\n    }\r\n  \r\n    getEmptyNodes(grid) {\r\n        var emptyNodes = [];\r\n        // Get all empty nodes\r\n        for(var row of grid){\r\n            var newRow = row.filter(node => node.type === \"default\");\r\n            if(newRow.length > 0) emptyNodes.push(newRow);\r\n        }\r\n        return emptyNodes;\r\n    }\r\n\r\n    randomizeStartFinishNodes() {\r\n        var {grid, startNodeCoords, finishNodeCoords } = this.state;\r\n        \r\n        grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"default\", Infinity);\r\n        grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"default\", Infinity);\r\n        \r\n        // Get all empty nodes\r\n        var emptyNodes = this.getEmptyNodes(grid);\r\n\r\n        if(emptyNodes.length > 0) {\r\n            var startNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var startNode = emptyNodes[startNodeRow][randomInteger(0, emptyNodes[startNodeRow].length - 1)];\r\n            var finishNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var finishNode = emptyNodes[finishNodeRow][randomInteger(0, emptyNodes[finishNodeRow].length - 1)];\r\n    \r\n            startNodeCoords = [startNode.row, startNode.col];\r\n            finishNodeCoords = [finishNode.row, finishNode.col];\r\n            \r\n            grid[startNodeCoords[0]][startNodeCoords[1]] = createNode(startNodeCoords[0], startNodeCoords[1], \"startNode\", 0);\r\n            grid[finishNodeCoords[0]][finishNodeCoords[1]] = createNode(finishNodeCoords[0], finishNodeCoords[1], \"finishNode\", Infinity);\r\n            \r\n            this.setState({ grid, startNodeCoords, finishNodeCoords });\r\n        }\r\n    }\r\n\r\n    addCheckpointNode(){\r\n        var { grid, checkpointNodes, isPathDrawn } = this.state;\r\n\r\n        // If there is a path, clear it and mark checkpoints as unvisited \r\n        if(isPathDrawn) {\r\n            clearPath(this);\r\n            // Reset checkpoint node states\r\n            for(let checkpointNodeInfo of checkpointNodes){\r\n                checkpointNodeInfo.isVisited = false;\r\n            }\r\n        }\r\n        \r\n        // Get all empty nodes\r\n        var emptyNodes = this.getEmptyNodes(grid);\r\n\r\n        // If there is empty space, add a checkpoint node\r\n        if(emptyNodes.length > 0) {\r\n            var checkpointNodeRow = randomInteger(0, emptyNodes.length - 1);\r\n            var checkpointNode = emptyNodes[checkpointNodeRow][randomInteger(0, emptyNodes[checkpointNodeRow].length - 1)];\r\n            var checkpointNodeCoords = [checkpointNode.row, checkpointNode.col];\r\n            var checkpointNodeInfo = {\r\n                id:checkpointNodes.length + 1,\r\n                coords:checkpointNodeCoords,\r\n                isVisited:false\r\n            };\r\n    \r\n            grid[checkpointNodeCoords[0]][checkpointNodeCoords[1]] = createNode(checkpointNodeCoords[0], checkpointNodeCoords[1], \"checkpointNode\", Infinity, checkpointNodeInfo.id);\r\n            \r\n            checkpointNodes.push(checkpointNodeInfo);\r\n            // Update the state\r\n            this.setState({ grid, checkpointNodes });\r\n        }\r\n    }\r\n\r\n    getDestinationNodeInfo() {\r\n        var { checkpointNodes, finishNodeCoords } = this.state;\r\n        for(var checkpointNodeInfo of checkpointNodes.reverse()) {\r\n            if(!checkpointNodeInfo.isVisited) return checkpointNodeInfo;\r\n        }\r\n\r\n        return {id:0, coords:finishNodeCoords, isVisited: false};\r\n    }\r\n\r\n    render() {\r\n        const {grid, startNodeCoords, finishNodeCoords, runTimeSeconds, numNodesInPath, numVisitedNodes, numWalls, lastAlgoRunString} = this.state;\r\n\r\n        return (\r\n            <div className='body'>\r\n                <div className='menu'>\r\n                    <h1 className='title'>Pathfinding Visualizer</h1>\r\n                    <div className='menu-group-container'>\r\n                        <div className='menu-group'>\r\n                            <h2>Pathfinding</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeDijkstra, \"Dijkstra\", this, grid, startNodeCoords, finishNodeCoords)}>Dijkstra's Algorithm</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeAStar, \"A*\", this, grid, startNodeCoords, finishNodeCoords)}>A*</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeDFS, \"DFS\", this, grid, startNodeCoords, finishNodeCoords)}>DFS</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizAlgorithm(computeBFS, \"BFS\", this, grid, startNodeCoords, finishNodeCoords)}>BFS</button>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Generators</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={() => visualizeRecursiveDivision(this, grid, startNodeCoords, finishNodeCoords)}>Recursive Division</button>\r\n                        </div>\r\n                        <div className='menu-group'>\r\n                            <h2>Board Options</h2>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> this.addCheckpointNode()}>Add checkpoint</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> resetGrid(this)}>Clear Board</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this)}>Clear Path</button>\r\n                            <button className=\"btn btn-outline-dark\" disabled={this.state.running} onClick={()=> clearPath(this, this.randomizeStartFinishNodes)}>Randomize Start and End Nodes</button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"grid-container\">\r\n                    <Legend></Legend>\r\n                    <Stats\r\n                        runTimeSeconds={runTimeSeconds}\r\n                        numNodesInPath={numNodesInPath}\r\n                        numVisitedNodes={numVisitedNodes}\r\n                        numWalls={numWalls}\r\n                        lastAlgoRunString={lastAlgoRunString}\r\n                        ></Stats>\r\n                    <div className=\"grid\">\r\n                        {grid.map((row, rowIdx) => {\r\n                            return (\r\n                                <div key={rowIdx}>\r\n                                    {row.map((node, nodeIdx) => {\r\n                                        const { row, col, type, distance, text } = node;\r\n                                        return (\r\n                                            <Node\r\n                                                key={nodeIdx}\r\n                                                className='node'\r\n                                                row={row}\r\n                                                col={col}\r\n                                                type={type}\r\n                                                text={text}\r\n                                                distance={distance}\r\n                                                onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                                onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                                onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                                                onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\r\n                                            ></Node>);\r\n                                    })}\r\n                                </div>\r\n                            );\r\n                        })}\r\n                    </div>\r\n                </div>\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction getWallUpdatedGrid(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        type: node.type === \"wallNode\" ? \"default\" : node.type === \"default\" ? \"wallNode\" : node.type\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\nfunction getNodeUpdatedGrid(grid, row, col, type, text=\"\") {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    var newNode = {\r\n        ...node,\r\n        text,\r\n        type\r\n    };\r\n\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport AlgoVisuaizer from './AlgoVisualizer/AlgoVisualizer';\r\n\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <AlgoVisuaizer></AlgoVisuaizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}